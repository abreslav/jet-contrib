diff --git a/.idea/modules.xml b/.idea/modules.xml
index 463eb8b..3e5a877 100644
--- a/.idea/modules.xml
+++ b/.idea/modules.xml
@@ -11,6 +11,7 @@
       <module fileurl="file://$PROJECT_DIR$/compiler/frontend.java/frontend.java.iml" filepath="$PROJECT_DIR$/compiler/frontend.java/frontend.java.iml" />
       <module fileurl="file://$PROJECT_DIR$/grammar/grammar.iml" filepath="$PROJECT_DIR$/grammar/grammar.iml" />
       <module fileurl="file://$PROJECT_DIR$/idea/idea.iml" filepath="$PROJECT_DIR$/idea/idea.iml" />
+      <module fileurl="file://$PROJECT_DIR$/j2k/j2k.iml" filepath="$PROJECT_DIR$/j2k/j2k.iml" />
       <module fileurl="file://$PROJECT_DIR$/stdlib/stdlib.iml" filepath="$PROJECT_DIR$/stdlib/stdlib.iml" />
     </modules>
   </component>
diff --git a/idea/idea.iml b/idea/idea.iml
index 061858a..50f1bf2 100644
--- a/idea/idea.iml
+++ b/idea/idea.iml
@@ -21,6 +21,7 @@
     <orderEntry type="module" module-name="frontend.java" />
     <orderEntry type="module" module-name="stdlib" />
     <orderEntry type="module" module-name="compiler-tests" />
+    <orderEntry type="module" module-name="j2k" />
   </component>
 </module>
 
diff --git a/idea/src/META-INF/plugin.xml b/idea/src/META-INF/plugin.xml
index 6fd690e..729541e 100644
--- a/idea/src/META-INF/plugin.xml
+++ b/idea/src/META-INF/plugin.xml
@@ -24,6 +24,11 @@
          <keyboard-shortcut keymap="$default" first-keystroke="control alt shift T"/>
          <add-to-group group-id="CodeMenu" anchor="last"/>
      </action>
+     <action id="ConvertJavaToKotlin" class="org.jetbrains.jet.plugin.actions.JavaToKotlinAction"
+             text="Convert Java File to Kotlin File">
+         <keyboard-shortcut keymap="$default" first-keystroke="control alt shift J"/>
+         <add-to-group group-id="CodeMenu" anchor="last"/>
+     </action>
      <action id="ToggleJetErrorReporting" class="org.jetbrains.jet.plugin.actions.ToggleErrorReportingAction"
              text="Toggle Error Reporting">
          <keyboard-shortcut keymap="$default" first-keystroke="control alt shift E"/>
diff --git a/idea/src/org/jetbrains/jet/plugin/actions/JavaToKotlinAction.java b/idea/src/org/jetbrains/jet/plugin/actions/JavaToKotlinAction.java
new file mode 100644
index 0000000..48d8736
--- /dev/null
+++ b/idea/src/org/jetbrains/jet/plugin/actions/JavaToKotlinAction.java
@@ -0,0 +1,62 @@
+package org.jetbrains.jet.plugin.actions;
+
+import com.intellij.ide.highlighter.JavaFileType;
+import com.intellij.openapi.actionSystem.AnAction;
+import com.intellij.openapi.actionSystem.AnActionEvent;
+import com.intellij.openapi.actionSystem.PlatformDataKeys;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiFile;
+
+import java.util.List;
+
+import static org.jetbrains.jet.j2k.Converter.clearClassIdentifiers;
+import static org.jetbrains.jet.plugin.actions.JavaToKotlinActionUtil.*;
+
+/**
+ * @author ignatov
+ */
+public class JavaToKotlinAction extends AnAction {
+    @Override
+    public void actionPerformed(final AnActionEvent e) {
+        VirtualFile[] virtualFiles = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);
+        final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());
+        assert virtualFiles != null;
+        assert project != null;
+        final List<PsiFile> allJavaFiles = getAllJavaFiles(virtualFiles, project);
+
+        clearClassIdentifiers();
+        for (PsiFile f : allJavaFiles) {
+            if (f.getFileType() instanceof JavaFileType) {
+                setClassIdentifiers(f);
+            }
+        }
+
+        final List<PsiFile> allJavaFilesNear = getAllJavaFiles(virtualFiles, project);
+        CommandProcessor.getInstance().executeCommand(
+                project,
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        final List<VirtualFile> newFiles = performFiles(allJavaFilesNear);
+                        deleteFiles(allJavaFilesNear);
+                        reformatFiles(newFiles, project);
+                        for (VirtualFile vf : newFiles) {
+                            FileEditorManager.getInstance(project).openFile(vf, true);
+                        }
+                    }
+                },
+                "Convert files from Java to Kotlin",
+                "group_id"
+        );
+    }
+
+    @Override
+    public void update(AnActionEvent e) {
+        final boolean enabled = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY) != null;
+        e.getPresentation().setVisible(enabled);
+        e.getPresentation().setEnabled(enabled);
+    }
+}
\ No newline at end of file
diff --git a/idea/src/org/jetbrains/jet/plugin/actions/JavaToKotlinActionUtil.java b/idea/src/org/jetbrains/jet/plugin/actions/JavaToKotlinActionUtil.java
new file mode 100644
index 0000000..90967c1
--- /dev/null
+++ b/idea/src/org/jetbrains/jet/plugin/actions/JavaToKotlinActionUtil.java
@@ -0,0 +1,132 @@
+package org.jetbrains.jet.plugin.actions;
+
+import com.intellij.ide.highlighter.JavaFileType;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.ex.MessagesEx;
+import com.intellij.openapi.vfs.CharsetToolkit;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiJavaFile;
+import com.intellij.psi.PsiManager;
+import com.intellij.psi.codeStyle.CodeStyleManager;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.j2k.Converter;
+import org.jetbrains.jet.j2k.visitors.ClassVisitor;
+
+import java.io.IOException;
+import java.util.*;
+
+/**
+ * @author ignatov
+ */
+public class JavaToKotlinActionUtil {
+    static void setClassIdentifiers(@NotNull PsiFile psiFile) {
+        ClassVisitor c = new ClassVisitor();
+        psiFile.accept(c);
+        Converter.setClassIdentifiers(c.getClassIdentifiers());
+    }
+
+    @NotNull
+    private static List<VirtualFile> getChildrenRecursive(@Nullable VirtualFile baseDir) {
+        List<VirtualFile> result = new LinkedList<VirtualFile>();
+        VirtualFile[] children = baseDir != null ? baseDir.getChildren() : VirtualFile.EMPTY_ARRAY;
+        result.addAll(Arrays.asList(children));
+        for (VirtualFile f : children)
+            result.addAll(getChildrenRecursive(f));
+        return result;
+    }
+
+    @NotNull
+    static List<PsiFile> getAllJavaFiles(@NotNull VirtualFile[] vFiles, Project project) {
+        final PsiManager manager = PsiManager.getInstance(project);
+        Set<VirtualFile> filesSet = new HashSet<VirtualFile>();
+        for (VirtualFile f : vFiles) {
+            filesSet.add(f);
+            filesSet.addAll(getChildrenRecursive(f));
+        }
+        final List<PsiFile> res = new ArrayList<PsiFile>();
+        for (final VirtualFile file : filesSet) {
+            final PsiFile psiFile = manager.findFile(file);
+            if (psiFile != null && psiFile.getFileType() instanceof JavaFileType) {
+                res.add(psiFile);
+            }
+        }
+        return res;
+    }
+
+    static void reformatFiles(List<VirtualFile> allJetFiles, final Project project) {
+        for (final VirtualFile vf : allJetFiles)
+            ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                @Override
+                public void run() {
+                    if (vf != null) {
+                        PsiFile psiFile = PsiManager.getInstance(project).findFile(vf);
+                        if (psiFile != null) {
+                            CodeStyleManager.getInstance(project).reformat(psiFile);
+                        }
+                    }
+                }
+            });
+    }
+
+    @NotNull
+    static List<VirtualFile> performFiles(List<PsiFile> allJavaFilesNear) {
+        final List<VirtualFile> result = new LinkedList<VirtualFile>();
+        for (final PsiFile f : allJavaFilesNear) {
+            ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                @Override
+                public void run() {
+                    VirtualFile vf = performOneFile(f);
+                    if (vf != null) {
+                        result.add(vf);
+                    }
+                }
+            });
+        }
+        return result;
+    }
+
+    static void deleteFiles(List<PsiFile> allJavaFilesNear) {
+        for (final PsiFile f : allJavaFilesNear) {
+            ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        PsiManager manager = f.getManager();
+                        VirtualFile vFile = f.getVirtualFile();
+                        if (vFile != null) {
+                            vFile.delete(manager);
+                        }
+                    } catch (IOException ignored) {
+                    }
+                }
+            });
+        }
+    }
+
+    @Nullable
+    private static VirtualFile performOneFile(PsiFile psiFile) {
+        try {
+            VirtualFile virtualFile = psiFile.getVirtualFile();
+            if (psiFile instanceof PsiJavaFile && virtualFile != null) {
+                String result = "";
+                try {
+                    result = Converter.fileToFileWithCompatibilityImport((PsiJavaFile) psiFile).toKotlin();
+                } catch (Exception e) {
+                    //noinspection CallToPrintStackTrace
+                    e.printStackTrace();
+                }
+                final PsiManager manager = psiFile.getManager();
+                assert manager != null;
+                VirtualFile copy = virtualFile.copy(manager, virtualFile.getParent(), virtualFile.getNameWithoutExtension() + ".kt");
+                copy.setBinaryContent(CharsetToolkit.getUtf8Bytes(result));
+                return copy;
+            }
+        } catch (Exception ex) {
+            MessagesEx.error(psiFile.getProject(), ex.getMessage()).showLater();
+        }
+        return null;
+    }
+}
diff --git a/j2k/j2k.iml b/j2k/j2k.iml
new file mode 100644
index 0000000..538b979
--- /dev/null
+++ b/j2k/j2k.iml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+    </content>
+    <orderEntry type="jdk" jdkName="IDEA 10.x" jdkType="IDEA JDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
diff --git a/j2k/j2k.ipr b/j2k/j2k.ipr
new file mode 100644
index 0000000..0725715
--- /dev/null
+++ b/j2k/j2k.ipr
@@ -0,0 +1,188 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AntConfiguration">
+    <defaultAnt bundledAnt="true" />
+  </component>
+  <component name="CompilerConfiguration">
+    <option name="DEFAULT_COMPILER" value="Javac" />
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="?*.properties" />
+      <entry name="?*.xml" />
+      <entry name="?*.gif" />
+      <entry name="?*.png" />
+      <entry name="?*.jpeg" />
+      <entry name="?*.jpg" />
+      <entry name="?*.html" />
+      <entry name="?*.dtd" />
+      <entry name="?*.tld" />
+      <entry name="?*.ftl" />
+    </wildcardResourcePatterns>
+    <annotationProcessing enabled="false" useClasspath="true" />
+  </component>
+  <component name="CopyrightManager" default="">
+    <module2copyright />
+  </component>
+  <component name="DependencyValidationManager">
+    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
+  </component>
+  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="IdProvider" IDEtalkID="85E718DEBECB31403A7B26BEC4D25543" />
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+  <component name="ProjectDictionaryState">
+    <dictionary name="ignatov">
+      <words>
+        <w>kotlin</w>
+        <w>nullable</w>
+      </words>
+    </dictionary>
+  </component>
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/j2k.iml" filepath="$PROJECT_DIR$/j2k.iml" />
+    </modules>
+  </component>
+  <component name="ProjectResources">
+    <default-html-doctype>http://www.w3.org/1999/xhtml</default-html-doctype>
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_6" assert-keyword="true" jdk-15="true" project-jdk-name="IDEA 10.x" project-jdk-type="IDEA JDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
+  </component>
+  <component name="WebServicesPlugin" addRequiredLibraries="true" />
+  <component name="libraryTable">
+    <library name="commons-io-2.1">
+      <CLASSES>
+        <root url="jar://$PROJECT_DIR$/lib/commons-io-2.1.jar!/" />
+      </CLASSES>
+      <JAVADOC />
+      <SOURCES />
+    </library>
+  </component>
+</project>
+
diff --git a/j2k/src/org/jetbrains/jet/j2k/Converter.java b/j2k/src/org/jetbrains/jet/j2k/Converter.java
new file mode 100644
index 0000000..8842561
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/Converter.java
@@ -0,0 +1,547 @@
+package org.jetbrains.jet.j2k;
+
+import com.intellij.psi.*;
+import com.intellij.psi.search.searches.ReferencesSearch;
+import com.intellij.psi.util.PsiUtil;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.j2k.ast.*;
+import org.jetbrains.jet.j2k.ast.Class;
+import org.jetbrains.jet.j2k.ast.Enum;
+import org.jetbrains.jet.j2k.ast.Modifier;
+import org.jetbrains.jet.j2k.util.AstUtil;
+import org.jetbrains.jet.j2k.visitors.*;
+
+import java.util.*;
+
+/**
+ * @author ignatov
+ */
+public class Converter {
+  private final static Set<String> NOT_NULL_ANNOTATIONS = new HashSet<String>() {
+    {
+      add("org.jetbrains.annotations.NotNull");
+      add("com.sun.istack.internal.NotNull");
+      add("javax.annotation.Nonnull");
+    }
+  };
+  @NotNull private static Set<String> ourClassIdentifiers = new HashSet<String>();
+  @NotNull private static final Dispatcher ourDispatcher = new Dispatcher();
+  @Nullable private static PsiType ourMethodReturnType = null;
+
+  public static void setClassIdentifiers(Set<String> identifiers) {
+    ourClassIdentifiers = identifiers;
+  }
+
+  public static Set<String> getClassIdentifiers() {
+    return new HashSet<String>(ourClassIdentifiers);
+  }
+
+  @Nullable
+  public static PsiType getMethodReturnType() {
+    return ourMethodReturnType;
+  }
+
+  public static void clearClassIdentifiers() {
+    ourClassIdentifiers.clear();
+  }
+
+  @NotNull
+  public static File fileToFile(@NotNull PsiJavaFile javaFile) {
+    final PsiImportList importList = javaFile.getImportList();
+    List<Import> imports = importList == null ? Collections.<Import>emptyList() : importsToImportList(importList.getAllImportStatements());
+    return new File(quoteKeywords(javaFile.getPackageName()), imports, classesToClassList(javaFile.getClasses()));
+  }
+
+  @NotNull
+  public static File fileToFileWithCompatibilityImport(@NotNull PsiJavaFile javaFile) {
+    final PsiImportList importList = javaFile.getImportList();
+    List<Import> imports = importList == null ? Collections.<Import>emptyList() : importsToImportList(importList.getAllImportStatements());
+    imports.add(new Import("std.compatibility.*"));
+    return new File(quoteKeywords(javaFile.getPackageName()), imports, classesToClassList(javaFile.getClasses()));
+  }
+
+  @NotNull
+  private static String quoteKeywords(@NotNull String packageName) {
+    List<String> result = new LinkedList<String>();
+    for (String part : packageName.split("\\."))
+      result.add(new IdentifierImpl(part).toKotlin());
+    return AstUtil.join(result, ".");
+  }
+
+  @NotNull
+  private static List<Class> classesToClassList(@NotNull PsiClass[] classes) {
+    List<Class> result = new LinkedList<Class>();
+    for (PsiClass t : classes) result.add(classToClass(t));
+    return result;
+  }
+
+  @NotNull
+  public static AnonymousClass anonymousClassToAnonymousClass(@NotNull PsiAnonymousClass anonymousClass) {
+    return new AnonymousClass(getMembers(anonymousClass));
+  }
+
+  private static List<Member> getMembers(PsiClass psiClass) {
+    List<Member> members = new LinkedList<Member>();
+    for (PsiElement e : psiClass.getChildren()) {
+      if (e instanceof PsiMethod) members.add(methodToFunction((PsiMethod) e, true));
+      else if (e instanceof PsiField) members.add(fieldToField((PsiField) e));
+      else if (e instanceof PsiClass) members.add(classToClass((PsiClass) e));
+      else if (e instanceof PsiClassInitializer) members.add(initializerToInitializer((PsiClassInitializer) e));
+      else if (e instanceof PsiMember) System.out.println(e.getClass() + " " + e.getText());
+    }
+    return members;
+  }
+
+  @NotNull
+  private static List<Field> getFinalOrWithEmptyInitializer(@NotNull List<? extends Field> fields) {
+    List<Field> result = new LinkedList<Field>();
+    for (Field f : fields)
+      if (f.isFinal() || f.getInitializer().toKotlin().isEmpty())
+        result.add(f);
+    return result;
+  }
+
+  @NotNull
+  private static List<Parameter> createParametersFromFields(@NotNull List<? extends Field> fields) {
+    List<Parameter> result = new LinkedList<Parameter>();
+    for (Field f : fields) result.add(new Parameter(f.getIdentifier(), f.getType()));
+    return result;
+  }
+
+  @NotNull
+  private static List<Statement> createInitStatementsFromFields(@NotNull List<? extends Field> fields) {
+    List<Statement> result = new LinkedList<Statement>();
+    for (Field f : fields) {
+      final String identifierToKotlin = f.getIdentifier().toKotlin();
+      result.add(new DummyStringExpression("$" + identifierToKotlin + " = " + identifierToKotlin));
+    }
+    return result;
+  }
+
+  @NotNull
+  private static String createPrimaryConstructorInvocation(@NotNull String s, @NotNull List<? extends Field> fields, @NotNull Map<String, String> initializers) {
+    List<String> result = new LinkedList<String>();
+    for (Field f : fields) {
+      final String id = f.getIdentifier().toKotlin();
+      result.add(initializers.get(id));
+    }
+    return s + "(" + AstUtil.join(result, ", ") + ")";
+  }
+
+  @NotNull
+  private static Class classToClass(@NotNull PsiClass psiClass) {
+    final Set<String> modifiers = modifiersListToModifiersSet(psiClass.getModifierList());
+    final List<Field> fields = fieldsToFieldList(psiClass.getFields());
+    final List<Element> typeParameters = elementsToElementList(psiClass.getTypeParameters());
+    final List<Type> implementsTypes = typesToNotNullableTypeList(psiClass.getImplementsListTypes());
+    final List<Type> extendsTypes = typesToNotNullableTypeList(psiClass.getExtendsListTypes());
+    final IdentifierImpl name = new IdentifierImpl(psiClass.getName());
+    final List<Expression> baseClassParams = new LinkedList<Expression>();
+
+    List<Member> members = getMembers(psiClass);
+
+    // we try to find super() call and generate class declaration like that: class A(name: String, i : Int) : Base(name)
+    final SuperVisitor visitor = new SuperVisitor();
+    psiClass.accept(visitor);
+    final HashSet<PsiExpressionList> resolvedSuperCallParameters = visitor.getResolvedSuperCallParameters();
+    if (resolvedSuperCallParameters.size() == 1)
+      baseClassParams.addAll(
+        expressionsToExpressionList(
+          resolvedSuperCallParameters.toArray(new PsiExpressionList[1])[0].getExpressions()
+        )
+      );
+
+    // we create primary constructor from all non final fields and fields without initializers
+    if (!psiClass.isEnum() && !psiClass.isInterface() && psiClass.getConstructors().length > 1 && getPrimaryConstructorForThisCase(psiClass) == null) {
+      final List<Field> finalOrWithEmptyInitializer = getFinalOrWithEmptyInitializer(fields);
+      final Map<String, String> initializers = new HashMap<String, String>();
+
+      for (final Member m : members) {
+        // and modify secondaries
+        if (m.getKind() == INode.Kind.CONSTRUCTOR) {
+          Function f = (Function) m;
+          if (!((Constructor) f).isPrimary()) {
+            for (Field fo : finalOrWithEmptyInitializer) {
+              String init = getDefaultInitializer(fo);
+              initializers.put(fo.getIdentifier().toKotlin(), init);
+            }
+
+            final List<Statement> newStatements = new LinkedList<Statement>();
+
+            for (Statement s : f.getBlock().getStatements()) {
+              boolean isRemoved = false;
+
+              if (s.getKind() == INode.Kind.ASSIGNMENT_EXPRESSION) {
+                final AssignmentExpression assignmentExpression = (AssignmentExpression) s;
+                if (assignmentExpression.getLeft().getKind() == INode.Kind.CALL_CHAIN) {
+                  for (Field fo : finalOrWithEmptyInitializer) {
+                    final String id = fo.getIdentifier().toKotlin();
+                    if (((CallChainExpression) assignmentExpression.getLeft()).getIdentifier().toKotlin().endsWith("." + id)) {
+                      initializers.put(id, assignmentExpression.getRight().toKotlin());
+                      isRemoved = true;
+                    }
+                  }
+                }
+              }
+              if (!isRemoved) {
+                newStatements.add(s);
+              }
+            }
+
+            newStatements.add(
+              0,
+              new DummyStringExpression(
+                "val __ = " + createPrimaryConstructorInvocation(
+                  name.toKotlin(),
+                  finalOrWithEmptyInitializer,
+                  initializers)));
+
+            f.setBlock(new Block(newStatements));
+          }
+        }
+      }
+
+      members.add(
+        new Constructor(
+          Identifier.EMPTY_IDENTIFIER,
+          Collections.<String>emptySet(),
+          new ClassType(name),
+          Collections.<Element>emptyList(),
+          new ParameterList(createParametersFromFields(finalOrWithEmptyInitializer)),
+          new Block(createInitStatementsFromFields(finalOrWithEmptyInitializer)),
+          true
+        )
+      );
+    }
+
+    if (psiClass.isInterface())
+      return new Trait(name, modifiers, typeParameters, extendsTypes, Collections.<Expression>emptyList(), implementsTypes, members);
+    if (psiClass.isEnum())
+      return new Enum(name, modifiers, typeParameters, Collections.<Type>emptyList(), Collections.<Expression>emptyList(), implementsTypes, members);
+    return new Class(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, members);
+  }
+
+  @NotNull
+  private static Initializer initializerToInitializer(PsiClassInitializer i) {
+    return new Initializer(
+      blockToBlock(i.getBody(), true),
+      modifiersListToModifiersSet(i.getModifierList())
+    );
+  }
+
+  @NotNull
+  public static String getDefaultInitializer(@NotNull Field f) {
+    if (f.getType().isNullable())
+      return "null";
+    else {
+      final String typeToKotlin = f.getType().toKotlin();
+      if (typeToKotlin.equals("Boolean")) return "false";
+      if (typeToKotlin.equals("Char")) return "' '";
+      if (typeToKotlin.equals("Double")) return "0.dbl";
+      if (typeToKotlin.equals("Float")) return "0.flt";
+      return "0";
+    }
+  }
+
+  @NotNull
+  private static List<Field> fieldsToFieldList(@NotNull PsiField[] fields) {
+    List<Field> result = new LinkedList<Field>();
+    for (PsiField f : fields) result.add(fieldToField(f));
+    return result;
+  }
+
+  @NotNull
+  private static Field fieldToField(@NotNull PsiField field) {
+    Set<String> modifiers = modifiersListToModifiersSet(field.getModifierList());
+    if (field instanceof PsiEnumConstant) // TODO: remove instanceof
+      return new EnumConstant(
+        new IdentifierImpl(field.getName()), // TODO
+        modifiers,
+        typeToType(field.getType()),
+        elementToElement(((PsiEnumConstant) field).getArgumentList())
+      );
+    return new Field(
+      new IdentifierImpl(field.getName()), // TODO
+      modifiers,
+      typeToType(field.getType()),
+      expressionToExpression(field.getInitializer()) // TODO: add modifiers
+    );
+  }
+
+  @Nullable
+  private static PsiMethod getPrimaryConstructorForThisCase(@NotNull PsiClass psiClass) {
+    ThisVisitor tv = new ThisVisitor();
+    psiClass.accept(tv);
+    return tv.getPrimaryConstructor();
+  }
+
+  public static boolean isConstructorPrimary(@NotNull PsiMethod constructor) {
+    if (constructor.getParent() instanceof PsiClass) {
+      final PsiClass parent = (PsiClass) constructor.getParent();
+      if (parent.getConstructors().length == 1)
+        return true;
+      else {
+        PsiMethod c = getPrimaryConstructorForThisCase(parent); // TODO: move up to classToClass() method
+        if (c != null && c.hashCode() == constructor.hashCode())
+          return true;
+      }
+    }
+    return false;
+  }
+
+  @NotNull
+  private static List<Statement> removeEmpty(@NotNull List<Statement> statements) {
+    List<Statement> result = new LinkedList<Statement>();
+    for (Statement s : statements)
+      if (s != Statement.EMPTY_STATEMENT && s != Expression.EMPTY_EXPRESSION)
+        result.add(s);
+    return result;
+  }
+
+  @NotNull
+  private static Function methodToFunction(@NotNull PsiMethod method, boolean notEmpty) {
+    if (isOverrideObjectDirect(method))
+      ourDispatcher.setExpressionVisitor(new ExpressionVisitorForDirectObjectInheritors());
+    else
+      ourDispatcher.setExpressionVisitor(new ExpressionVisitor());
+
+    ourMethodReturnType = method.getReturnType();
+
+    final IdentifierImpl identifier = new IdentifierImpl(method.getName());
+    final Type returnType = typeToType(method.getReturnType(), isNotNull(method.getModifierList()));
+    final Block body = blockToBlock(method.getBody(), notEmpty);
+    final Element params = elementToElement(method.getParameterList());
+    final List<Element> typeParameters = elementsToElementList(method.getTypeParameters());
+
+    final Set<String> modifiers = modifiersListToModifiersSet(method.getModifierList());
+    if (isOverrideAnyMethodExceptMethodsFromObject(method))
+      modifiers.add(Modifier.OVERRIDE);
+    if (method.getParent() instanceof PsiClass && ((PsiClass) method.getParent()).isInterface())
+      modifiers.remove(Modifier.ABSTRACT);
+    if (isNotOpenMethod(method))
+      modifiers.add(Modifier.NOT_OPEN);
+
+    if (method.isConstructor()) { // TODO: simplify
+      boolean isPrimary = isConstructorPrimary(method);
+      return new Constructor(
+        identifier,
+        modifiers,
+        returnType,
+        typeParameters,
+        params,
+        new Block(removeEmpty(body.getStatements()), false),
+        isPrimary
+      );
+    }
+    return new Function(
+      identifier,
+      modifiers,
+      returnType,
+      typeParameters,
+      params,
+      body
+    );
+  }
+
+  private static boolean isNotOpenMethod(final PsiMethod method) {
+    if (method.getParent() instanceof PsiClass) {
+      final PsiModifierList parentModifierList = ((PsiClass) method.getParent()).getModifierList();
+      if ((parentModifierList != null && parentModifierList.hasExplicitModifier(Modifier.FINAL)) || ((PsiClass) method.getParent()).isEnum())
+        return true;
+    }
+    return false;
+  }
+
+  private static boolean isOverrideAnyMethodExceptMethodsFromObject(@NotNull PsiMethod method) {
+    int counter = 0;
+    for (HierarchicalMethodSignature s : method.getHierarchicalMethodSignature().getSuperSignatures()) {
+      PsiClass containingClass = s.getMethod().getContainingClass();
+      String qualifiedName = containingClass != null ? containingClass.getQualifiedName() : "";
+      if (qualifiedName != null && !qualifiedName.equals("java.lang.Object"))
+        counter++;
+    }
+    return counter > 0;
+  }
+
+  private static boolean isOverrideObjectDirect(@NotNull final PsiMethod method) {
+    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();
+    if (superSignatures.size() == 1) {
+      final PsiClass containingClass = superSignatures.get(0).getMethod().getContainingClass();
+      final String qualifiedName = containingClass != null ? containingClass.getQualifiedName() : "";
+      if (qualifiedName != null && qualifiedName.equals("java.lang.Object"))
+        return true;
+    }
+    return false;
+  }
+
+  @NotNull
+  public static Block blockToBlock(@Nullable PsiCodeBlock block, boolean notEmpty) {
+    if (block == null) return Block.EMPTY_BLOCK;
+    return new Block(statementsToStatementList(block.getStatements()), notEmpty);
+  }
+
+  @NotNull
+  public static Block blockToBlock(@Nullable PsiCodeBlock block) {
+    return blockToBlock(block, true);
+  }
+
+  @NotNull
+  public static List<Statement> statementsToStatementList(@NotNull PsiStatement[] statements) {
+    List<Statement> result = new LinkedList<Statement>();
+    for (PsiStatement t : statements) result.add(statementToStatement(t));
+    return result;
+  }
+
+  @NotNull
+  public static List<Statement> statementsToStatementList(@NotNull List<PsiStatement> statements) {
+    List<Statement> result = new LinkedList<Statement>();
+    for (PsiStatement t : statements) result.add(statementToStatement(t));
+    return result;
+  }
+
+  @NotNull
+  public static Statement statementToStatement(@Nullable PsiStatement s) {
+    if (s == null) return Statement.EMPTY_STATEMENT;
+    final StatementVisitor statementVisitor = new StatementVisitor();
+    s.accept(statementVisitor);
+    return statementVisitor.getResult();
+  }
+
+  @NotNull
+  public static List<Expression> expressionsToExpressionList(@NotNull PsiExpression[] expressions) {
+    List<Expression> result = new LinkedList<Expression>();
+    for (PsiExpression e : expressions) result.add(expressionToExpression(e));
+    return result;
+  }
+
+  @NotNull
+  public static Expression expressionToExpression(@Nullable PsiExpression e) {
+    if (e == null) return Expression.EMPTY_EXPRESSION;
+    final ExpressionVisitor expressionVisitor = ourDispatcher.getExpressionVisitor();
+    e.accept(expressionVisitor);
+    return expressionVisitor.getResult();
+  }
+
+  @NotNull
+  public static Element elementToElement(@Nullable PsiElement e) {
+    if (e == null) return Element.EMPTY_ELEMENT;
+    final ElementVisitor elementVisitor = new ElementVisitor();
+    e.accept(elementVisitor);
+    return elementVisitor.getResult();
+  }
+
+  @NotNull
+  public static List<Element> elementsToElementList(@NotNull PsiElement[] elements) {
+    List<Element> result = new LinkedList<Element>();
+    for (PsiElement e : elements) result.add(elementToElement(e));
+    return result;
+  }
+
+  @NotNull
+  public static Type typeToType(@Nullable PsiType type) {
+    if (type == null) return Type.EMPTY_TYPE;
+    TypeVisitor typeVisitor = new TypeVisitor();
+    type.accept(typeVisitor);
+    return typeVisitor.getResult();
+  }
+
+  @NotNull
+  public static List<Type> typesToTypeList(@NotNull PsiType[] types) {
+    List<Type> result = new LinkedList<Type>();
+    for (PsiType t : types) result.add(typeToType(t));
+    return result;
+  }
+
+  public static Type typeToType(PsiType type, boolean notNull) {
+    Type result = typeToType(type);
+    if (notNull)
+      result.convertedToNotNull();
+    return result;
+  }
+
+  @NotNull
+  private static List<Type> typesToNotNullableTypeList(@NotNull PsiType[] types) {
+    List<Type> result = new LinkedList<Type>(typesToTypeList(types));
+    for (Type p : result) p.convertedToNotNull();
+    return result;
+  }
+
+  @NotNull
+  private static List<Import> importsToImportList(@NotNull PsiImportStatementBase[] imports) {
+    List<Import> result = new LinkedList<Import>();
+    for (PsiImportStatementBase i : imports) {
+      Import anImport = importToImport(i);
+      String name = anImport.getName();
+      if (!name.isEmpty() && !NOT_NULL_ANNOTATIONS.contains(name))
+        result.add(anImport);
+    }
+    return result;
+  }
+
+  @NotNull
+  private static Import importToImport(@NotNull PsiImportStatementBase i) {
+    final PsiJavaCodeReferenceElement reference = i.getImportReference();
+    if (reference != null)
+      return new Import(quoteKeywords(reference.getQualifiedName()) + (i.isOnDemand() ? ".*" : ""));
+    return new Import("");
+  }
+
+  @NotNull
+  public static List<Parameter> parametersToParameterList(@NotNull PsiParameter[] parameters) {
+    List<Parameter> result = new LinkedList<Parameter>();
+    for (PsiParameter t : parameters) result.add(parameterToParameter(t));
+    return result;
+  }
+
+  @NotNull
+  public static Parameter parameterToParameter(@NotNull PsiParameter parameter) {
+    return new Parameter(
+      new IdentifierImpl(parameter.getName()),
+      typeToType(parameter.getType(), isNotNull(parameter.getModifierList())),
+      isReadOnly(parameter)
+    );
+  }
+
+  public static boolean isNotNull(@Nullable PsiModifierList modifierList) {
+    if (modifierList != null) {
+      PsiAnnotation[] annotations = modifierList.getAnnotations();
+      for (PsiAnnotation a : annotations) {
+        String qualifiedName = a.getQualifiedName();
+        if (qualifiedName != null && NOT_NULL_ANNOTATIONS.contains(qualifiedName))
+          return true;
+      }
+    }
+    return false;
+  }
+
+  private static boolean isReadOnly(PsiParameter parameter) {
+    for (PsiReference r : (ReferencesSearch.search(parameter))) {
+      if (r instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression) r)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  @NotNull
+  public static Identifier identifierToIdentifier(@Nullable PsiIdentifier identifier) {
+    if (identifier == null) return Identifier.EMPTY_IDENTIFIER;
+    return new IdentifierImpl(identifier.getText());
+  }
+
+  @NotNull
+  public static Set<String> modifiersListToModifiersSet(PsiModifierList modifierList) {
+    HashSet<String> modifiersSet = new HashSet<String>();
+    if (modifierList != null) {
+      if (modifierList.hasExplicitModifier(PsiModifier.ABSTRACT)) modifiersSet.add(Modifier.ABSTRACT);
+      if (modifierList.hasModifierProperty(PsiModifier.FINAL)) modifiersSet.add(Modifier.FINAL);
+      if (modifierList.hasModifierProperty(PsiModifier.STATIC)) modifiersSet.add(Modifier.STATIC);
+      if (modifierList.hasExplicitModifier(PsiModifier.PUBLIC)) modifiersSet.add(Modifier.PUBLIC);
+      if (modifierList.hasExplicitModifier(PsiModifier.PROTECTED)) modifiersSet.add(Modifier.PROTECTED);
+      if (modifierList.hasExplicitModifier(PsiModifier.PACKAGE_LOCAL)) modifiersSet.add(Modifier.INTERNAL);
+      if (modifierList.hasExplicitModifier(PsiModifier.PRIVATE)) modifiersSet.add(Modifier.PRIVATE);
+    }
+    return modifiersSet;
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/AnonymousClass.java b/j2k/src/org/jetbrains/jet/j2k/ast/AnonymousClass.java
new file mode 100644
index 0000000..e8a87d2
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/AnonymousClass.java
@@ -0,0 +1,28 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class AnonymousClass extends Class {
+  public AnonymousClass(List<Member> members) {
+    super(new IdentifierImpl("anonClass"),
+      Collections.<String>emptySet(),
+      Collections.<Element>emptyList(),
+      Collections.<Type>emptyList(),
+      Collections.<Expression>emptyList(),
+      Collections.<Type>emptyList(),
+      members
+    );
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return bodyToKotlin();
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ArrayAccessExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/ArrayAccessExpression.java
new file mode 100644
index 0000000..4a511b7
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ArrayAccessExpression.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ArrayAccessExpression extends Expression {
+  private final Expression myExpression;
+  private final Expression myIndex;
+
+  public ArrayAccessExpression(Expression expression, Expression index) {
+    myExpression = expression;
+    myIndex = index;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myExpression.toKotlin() + "[" + myIndex.toKotlin() + "]";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ArrayInitializerExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/ArrayInitializerExpression.java
new file mode 100644
index 0000000..876dc90
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ArrayInitializerExpression.java
@@ -0,0 +1,23 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class ArrayInitializerExpression extends Expression {
+  private final List<Expression> myInitializers;
+
+  public ArrayInitializerExpression(List<Expression> initializers) {
+    myInitializers = initializers;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "array" + "(" + AstUtil.joinNodes(myInitializers, COMMA_WITH_SPACE) + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ArrayType.java b/j2k/src/org/jetbrains/jet/j2k/ast/ArrayType.java
new file mode 100644
index 0000000..970535a
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ArrayType.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ArrayType extends Type {
+  private final Type myType;
+
+  public ArrayType(Type type) {
+    myType = type;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (PRIMITIVE_TYPES.contains(myType.toKotlin().toLowerCase()))
+      return myType.toKotlin() + "Array" + isNullableStr(); // returns IntArray, BooleanArray, etc.
+    return "Array" + "<" + myType.toKotlin() + ">" + isNullableStr();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/AssertStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/AssertStatement.java
new file mode 100644
index 0000000..829f795
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/AssertStatement.java
@@ -0,0 +1,23 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class AssertStatement extends Statement {
+  private final Expression myCondition;
+  private final Expression myDetail;
+
+  public AssertStatement(Expression condition, Expression detail) {
+    myCondition = condition;
+    myDetail = detail;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String detail = myDetail != Expression.EMPTY_EXPRESSION ? "(" + myDetail.toKotlin() + ")" : EMPTY;
+    return "assert" + detail + SPACE + "{" + myCondition.toKotlin() + "}";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/AssignmentExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/AssignmentExpression.java
new file mode 100644
index 0000000..34d1fcb
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/AssignmentExpression.java
@@ -0,0 +1,38 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class AssignmentExpression extends Expression {
+  private final Expression myLeft;
+  private final Expression myRight;
+  private final String myOp;
+
+  public Expression getLeft() {
+    return myLeft;
+  }
+
+  public Expression getRight() {
+    return myRight;
+  }
+
+  public AssignmentExpression(Expression left, Expression right, String op) {
+    myLeft = left;
+    myRight = right;
+    myOp = op;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myLeft.toKotlin() + SPACE + myOp + SPACE + myRight.toKotlin();
+  }
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.ASSIGNMENT_EXPRESSION;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/BinaryExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/BinaryExpression.java
new file mode 100644
index 0000000..5be8a82
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/BinaryExpression.java
@@ -0,0 +1,24 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class BinaryExpression extends Expression {
+  private final Expression myLeft;
+  private final Expression myRight;
+  private final String myOp;
+
+  public BinaryExpression(Expression left, Expression right, String op) {
+    myLeft = left;
+    myRight = right;
+    myOp = op;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + myLeft.toKotlin() + SPACE + myOp + SPACE + myRight.toKotlin() + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Block.java b/j2k/src/org/jetbrains/jet/j2k/ast/Block.java
new file mode 100644
index 0000000..8d18507
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Block.java
@@ -0,0 +1,50 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class Block extends Statement {
+  public final static Block EMPTY_BLOCK = new Block();
+
+  private List<Statement> myStatements;
+  private boolean myNotEmpty = false;
+
+  private Block() {
+    myStatements = new LinkedList<Statement>();
+  }
+
+  public Block(List<Statement> statements) {
+    myStatements = new LinkedList<Statement>();
+    myStatements = statements;
+  }
+
+  public Block(List<Statement> statements, boolean notEmpty) {
+    myStatements = new LinkedList<Statement>();
+    myStatements = statements;
+    myNotEmpty = notEmpty;
+  }
+
+  public boolean isEmpty() {
+    return !myNotEmpty && myStatements.size() == 0;
+  }
+
+  public List<Statement> getStatements() {
+    return myStatements;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (!isEmpty())
+      return "{" + N +
+        AstUtil.joinNodes(myStatements, N) + N +
+        "}";
+    return EMPTY;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/BreakStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/BreakStatement.java
new file mode 100644
index 0000000..e48b8ad
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/BreakStatement.java
@@ -0,0 +1,31 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class BreakStatement extends Statement {
+  private Identifier myLabel = Identifier.EMPTY_IDENTIFIER;
+
+  public BreakStatement(Identifier label) {
+    myLabel = label;
+  }
+
+  public BreakStatement() {
+  }
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.BREAK;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myLabel.isEmpty())
+      return "break";
+    return "break" + AT + myLabel.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/CallChainExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/CallChainExpression.java
new file mode 100644
index 0000000..d98463f
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/CallChainExpression.java
@@ -0,0 +1,42 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class CallChainExpression extends Expression {
+  private final Expression myExpression;
+  private final Expression myIdentifier;
+
+  public Expression getIdentifier() {
+    return myIdentifier;
+  }
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.CALL_CHAIN;
+  }
+
+  public CallChainExpression(Expression expression, Expression identifier) {
+    myExpression = expression;
+    myIdentifier = identifier;
+  }
+
+  @Override
+  public boolean isNullable() {
+    return myIdentifier.isNullable();
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (!myExpression.isEmpty())
+      if (myExpression.isNullable())
+        return myExpression.toKotlin() + QUESTDOT + myIdentifier.toKotlin();
+      else
+        return myExpression.toKotlin() + DOT + myIdentifier.toKotlin();
+    return myIdentifier.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/CatchStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/CatchStatement.java
new file mode 100644
index 0000000..7db33c9
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/CatchStatement.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class CatchStatement extends Statement {
+  private final Parameter myVariable;
+  private final Block myBlock;
+
+  public CatchStatement(Parameter variable, Block block) {
+    myVariable = variable;
+    myBlock = block;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "catch" + SPACE + "(" + myVariable.toKotlin() + ")" + SPACE + myBlock.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Class.java b/j2k/src/org/jetbrains/jet/j2k/ast/Class.java
new file mode 100644
index 0000000..98c6680
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Class.java
@@ -0,0 +1,212 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+import static org.jetbrains.jet.j2k.util.AstUtil.*;
+
+/**
+ * @author ignatov
+ */
+public class Class extends Member {
+  String TYPE = "class";
+  final Identifier myName;
+  private final List<Expression> myBaseClassParams;
+  private final List<? extends Member> myMembers;
+  private final List<Element> myTypeParameters;
+  private final List<Type> myExtendsTypes;
+  private final List<Type> myImplementsTypes;
+
+  public Class(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,
+               List<Expression> baseClassParams, List<Type> implementsTypes, List<? extends Member> members) {
+    myName = name;
+    myBaseClassParams = baseClassParams;
+    myModifiers = modifiers;
+    myTypeParameters = typeParameters;
+    myExtendsTypes = extendsTypes;
+    myImplementsTypes = implementsTypes;
+    myMembers = members;
+  }
+
+
+  @Nullable
+  private Constructor getPrimaryConstructor() {
+    for (Member m : myMembers)
+      if (m.getKind() == Kind.CONSTRUCTOR)
+        if (((Constructor) m).isPrimary())
+          return (Constructor) m;
+    return null;
+  }
+
+  String primaryConstructorSignatureToKotlin() {
+    Constructor maybeConstructor = getPrimaryConstructor();
+    if (maybeConstructor != null)
+      return maybeConstructor.primarySignatureToKotlin();
+    return "(" + ")";
+  }
+
+  String primaryConstructorBodyToKotlin() {
+    Constructor maybeConstructor = getPrimaryConstructor();
+    if (maybeConstructor != null && !maybeConstructor.getBlock().isEmpty())
+      return maybeConstructor.primaryBodyToKotlin();
+    return EMPTY;
+  }
+
+  private boolean hasWhere() {
+    for (Element t : myTypeParameters)
+      if (t instanceof TypeParameter && ((TypeParameter) t).hasWhere())
+        return true;
+    return false;
+  }
+
+  String typeParameterWhereToKotlin() {
+    if (hasWhere()) {
+      List<String> wheres = new LinkedList<String>();
+      for (Element t : myTypeParameters)
+        if (t instanceof TypeParameter)
+          wheres.add(((TypeParameter) t).getWhereToKotlin());
+      return SPACE + "where" + SPACE + join(wheres, COMMA_WITH_SPACE) + SPACE;
+    }
+    return EMPTY;
+  }
+
+  @NotNull
+  LinkedList<Member> membersExceptConstructors() {
+    final LinkedList<Member> result = new LinkedList<Member>();
+    for (Member m : myMembers)
+      if (m.getKind() != Kind.CONSTRUCTOR)
+        result.add(m);
+    return result;
+  }
+
+  @NotNull
+  List<Function> secondaryConstructorsAsStaticInitFunction() {
+    final LinkedList<Function> result = new LinkedList<Function>();
+    for (Member m : myMembers)
+      if (m.getKind() == Kind.CONSTRUCTOR && !((Constructor) m).isPrimary()) {
+        Function f = (Function) m;
+        Set<String> modifiers = new HashSet<String>(m.myModifiers);
+        modifiers.add(Modifier.STATIC);
+
+        final List<Statement> statements = f.getBlock().getStatements();
+        statements.add(new ReturnStatement(new IdentifierImpl("__"))); // TODO: move to one place, find other __ usages
+        final Block block = new Block(statements);
+
+        final List<Element> typeParameters = new LinkedList<Element>();
+        if (f.getTypeParameters().size() == 0)
+          typeParameters.addAll(myTypeParameters);
+        else {
+          typeParameters.addAll(myTypeParameters);
+          typeParameters.addAll(f.getTypeParameters());
+        }
+
+        result.add(new Function(
+          new IdentifierImpl("init"),
+          modifiers,
+          new ClassType(myName),
+          typeParameters,
+          f.getParams(),
+          block
+        ));
+      }
+    return result;
+  }
+
+  String typeParametersToKotlin() {
+    return myTypeParameters.size() > 0 ? "<" + AstUtil.joinNodes(myTypeParameters, COMMA_WITH_SPACE) + ">" : EMPTY;
+  }
+
+  List<String> baseClassSignatureWithParams() {
+    if (TYPE.equals("class") && myExtendsTypes.size() == 1) {
+      LinkedList<String> result = new LinkedList<String>();
+      result.add(myExtendsTypes.get(0).toKotlin() + "(" + joinNodes(myBaseClassParams, COMMA_WITH_SPACE) + ")");
+      return result;
+    } else
+      return nodesToKotlin(myExtendsTypes);
+  }
+
+  String implementTypesToKotlin() {
+    List<String> allTypes = new LinkedList<String>() {
+      {
+        addAll(baseClassSignatureWithParams());
+        addAll(nodesToKotlin(myImplementsTypes));
+      }
+    };
+    return allTypes.size() == 0 ? EMPTY : SPACE + COLON + SPACE + join(allTypes, COMMA_WITH_SPACE);
+  }
+
+  String modifiersToKotlin() {
+    List<String> modifierList = new LinkedList<String>();
+
+    if (needAbstractModifier())
+      modifierList.add(Modifier.ABSTRACT);
+
+    modifierList.add(accessModifier());
+
+    if (needOpenModifier())
+      modifierList.add(Modifier.OPEN);
+
+    if (modifierList.size() > 0)
+      return join(modifierList, SPACE) + SPACE;
+
+    return EMPTY;
+  }
+
+  boolean needOpenModifier() {
+    return !myModifiers.contains(Modifier.FINAL);
+  }
+
+  boolean needAbstractModifier() {
+    return isAbstract();
+  }
+
+  String bodyToKotlin() {
+    return SPACE + "{" + N +
+      primaryConstructorBodyToKotlin() + N +
+      AstUtil.joinNodes(getNonStatic(membersExceptConstructors()), N) + N +
+      classObjectToKotlin() + N +
+      "}";
+  }
+
+  private static List<Member> getStatic(List<? extends Member> members) {
+    List<Member> result = new LinkedList<Member>();
+    for (Member m : members)
+      if (m.isStatic())
+        result.add(m);
+    return result;
+  }
+
+  private static List<Member> getNonStatic(List<? extends Member> members) {
+    List<Member> result = new LinkedList<Member>();
+    for (Member m : members)
+      if (!m.isStatic())
+        result.add(m);
+    return result;
+  }
+
+  private String classObjectToKotlin() {
+    final List<Member> staticMembers = new LinkedList<Member>(secondaryConstructorsAsStaticInitFunction());
+    staticMembers.addAll(getStatic(membersExceptConstructors()));
+    if (staticMembers.size() > 0) {
+      return "class" + SPACE + "object" + SPACE + "{" + N +
+        AstUtil.joinNodes(staticMembers, N) + N +
+        "}";
+    }
+    return EMPTY;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return modifiersToKotlin() + TYPE + SPACE + myName.toKotlin() + typeParametersToKotlin() + primaryConstructorSignatureToKotlin() +
+      implementTypesToKotlin() +
+      typeParameterWhereToKotlin() +
+      bodyToKotlin();
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ClassObjectAccessExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/ClassObjectAccessExpression.java
new file mode 100644
index 0000000..b16fedb
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ClassObjectAccessExpression.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ClassObjectAccessExpression extends Expression {
+  private final Element myTypeElement;
+
+  public ClassObjectAccessExpression(Element typeElement) {
+    myTypeElement = typeElement;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "getJavaClass" + "<" + myTypeElement.toKotlin() + ">";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ClassType.java b/j2k/src/org/jetbrains/jet/j2k/ast/ClassType.java
new file mode 100644
index 0000000..830c3a4
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ClassType.java
@@ -0,0 +1,33 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class ClassType extends Type {
+  private final Identifier myType;
+  private final List<Type> myParameters;
+
+  public ClassType(Identifier type, List<Type> parameters) {
+    myType = type;
+    myParameters = parameters;
+  }
+
+  public ClassType(Identifier type) {
+    myType = type;
+    myNullable = false;
+    myParameters = Collections.emptyList();
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String params = myParameters.size() == 0 ? EMPTY : "<" + AstUtil.joinNodes(myParameters, COMMA_WITH_SPACE) + ">";
+    return myType.toKotlin() + params + isNullableStr();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Constructor.java b/j2k/src/org/jetbrains/jet/j2k/ast/Constructor.java
new file mode 100644
index 0000000..9fe6b49
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Constructor.java
@@ -0,0 +1,36 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class Constructor extends Function {
+  private final boolean myIsPrimary;
+
+  public Constructor(Identifier identifier, Set<String> modifiers, Type type, List<Element> typeParameters, Element params, Block block, boolean isPrimary) {
+    super(identifier, modifiers, type, typeParameters, params, block);
+    myIsPrimary = isPrimary;
+  }
+
+  public String primarySignatureToKotlin() {
+    return "(" + myParams.toKotlin() + ")";
+  }
+
+  public String primaryBodyToKotlin() {
+    return myBlock.toKotlin();
+  }
+
+  public boolean isPrimary() {
+    return myIsPrimary;
+  }
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.CONSTRUCTOR;
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ContinueStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ContinueStatement.java
new file mode 100644
index 0000000..bfed924
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ContinueStatement.java
@@ -0,0 +1,31 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ContinueStatement extends Statement {
+  private Identifier myLabel = Identifier.EMPTY_IDENTIFIER;
+
+  public ContinueStatement(Identifier label) {
+    myLabel = label;
+  }
+
+  public ContinueStatement() {
+  }
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.CONTINUE;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myLabel.isEmpty())
+      return "continue";
+    return "continue" + AT + myLabel.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/DeclarationStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/DeclarationStatement.java
new file mode 100644
index 0000000..756153a
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/DeclarationStatement.java
@@ -0,0 +1,39 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class DeclarationStatement extends Statement {
+  private final List<Element> myElements;
+
+  public DeclarationStatement(List<Element> elements) {
+    myElements = elements;
+  }
+
+  private static List<String> toStringList(List<Element> elements) {
+    List<String> result = new LinkedList<String>();
+    for (Element e : elements) {
+      if (e instanceof LocalVariable) {
+        LocalVariable v = (LocalVariable) e;
+
+        final String varKeyword = v.hasModifier(Modifier.FINAL) ? "val" : "var";
+        result.add(
+          varKeyword + SPACE + e.toKotlin()
+        );
+      }
+    }
+    return result;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return AstUtil.join(toStringList(myElements), N);
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/DoWhileStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/DoWhileStatement.java
new file mode 100644
index 0000000..02d4f64
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/DoWhileStatement.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class DoWhileStatement extends WhileStatement {
+  public DoWhileStatement(Expression condition, Statement statement) {
+    super(condition, statement);
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "do" + N +
+      myStatement.toKotlin() + N +
+      "while" + SPACE + "(" + myCondition.toKotlin() + ")";
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/DummyMethodCallExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/DummyMethodCallExpression.java
new file mode 100644
index 0000000..e304161
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/DummyMethodCallExpression.java
@@ -0,0 +1,24 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class DummyMethodCallExpression extends Expression {
+  private final Element myWho;
+  private final String myMethodName;
+  private final Element myWhat;
+
+  public DummyMethodCallExpression(Element who, String methodName, Element what) {
+    myWho = who;
+    myMethodName = methodName;
+    myWhat = what;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myWho.toKotlin() + DOT + myMethodName + "(" + myWhat.toKotlin() + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/DummyStringStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/DummyStringStatement.java
new file mode 100644
index 0000000..f9084fc
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/DummyStringStatement.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class DummyStringStatement extends Statement {
+  private final String myString;
+
+  public DummyStringStatement(String string) {
+    myString = string;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myString;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Element.java b/j2k/src/org/jetbrains/jet/j2k/ast/Element.java
new file mode 100644
index 0000000..16683fb
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Element.java
@@ -0,0 +1,30 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public abstract class Element extends Node {
+  public static final Element EMPTY_ELEMENT = new EmptyElement();
+
+  public boolean isEmpty() {
+    return false;
+  }
+
+  /**
+   * @author ignatov
+   */
+  private static class EmptyElement extends Element {
+    @NotNull
+    @Override
+    public String toKotlin() {
+      return EMPTY;
+    }
+
+    @Override
+    public boolean isEmpty() {
+      return true;
+    }
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Enum.java b/j2k/src/org/jetbrains/jet/j2k/ast/Enum.java
new file mode 100644
index 0000000..7ac18cf
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Enum.java
@@ -0,0 +1,39 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class Enum extends Class {
+  public Enum(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,
+              List<Expression> baseClassParams, List<Type> implementsTypes, List<Member> members) {
+    super(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, members);
+  }
+
+  String primaryConstructorSignatureToKotlin() {
+    String s = super.primaryConstructorSignatureToKotlin();
+    return s.equals("()") ? EMPTY : s;
+  }
+
+  @Override
+  boolean needOpenModifier() {
+    return false;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return modifiersToKotlin() + "enum class" + SPACE + myName.toKotlin() + primaryConstructorSignatureToKotlin() +
+      typeParametersToKotlin() + implementTypesToKotlin() + SPACE + "{" + N +
+      primaryConstructorBodyToKotlin() + N +
+      AstUtil.joinNodes(membersExceptConstructors(), N) + N +
+      "public fun name()  : String { return \"\" }" + N + // TODO : remove hack
+      "public fun order() : Int { return 0 }" + N +
+      "}";
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/EnumConstant.java b/j2k/src/org/jetbrains/jet/j2k/ast/EnumConstant.java
new file mode 100644
index 0000000..d83b2e5
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/EnumConstant.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class EnumConstant extends Field {
+  public EnumConstant(Identifier identifier, Set<String> modifiers, Type type, Element params) {
+    super(identifier, modifiers, type.convertedToNotNull(), params);
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myInitializer.toKotlin().isEmpty())
+      return myIdentifier.toKotlin();
+    return myIdentifier.toKotlin() + SPACE + COLON + SPACE + myType.toKotlin() + "(" + myInitializer.toKotlin() + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Expression.java b/j2k/src/org/jetbrains/jet/j2k/ast/Expression.java
new file mode 100644
index 0000000..7b2528b
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Expression.java
@@ -0,0 +1,30 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public abstract class Expression extends Statement {
+  public static final Expression EMPTY_EXPRESSION = new EmptyExpression();
+
+  /**
+   * @author ignatov
+   */
+  private static class EmptyExpression extends Expression {
+    @NotNull
+    @Override
+    public String toKotlin() {
+      return EMPTY;
+    }
+
+    @Override
+    public boolean isEmpty() {
+      return true;
+    }
+  }
+
+  boolean isNullable() {
+    return false;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ExpressionList.java b/j2k/src/org/jetbrains/jet/j2k/ast/ExpressionList.java
new file mode 100644
index 0000000..ae3c135
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ExpressionList.java
@@ -0,0 +1,27 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class ExpressionList extends Expression {
+  private final List<Expression> myExpressions;
+
+  public ExpressionList(List<Expression> expressions, List<Type> types) {
+    myExpressions = expressions;
+  }
+
+  public ExpressionList(List<Expression> expressions) {
+    myExpressions = expressions;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return AstUtil.joinNodes(myExpressions, COMMA_WITH_SPACE);
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ExpressionListStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ExpressionListStatement.java
new file mode 100644
index 0000000..1c67340
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ExpressionListStatement.java
@@ -0,0 +1,23 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class ExpressionListStatement extends Expression {
+  private final List<Expression> myExpressions;
+
+  public ExpressionListStatement(List<Expression> expressions) {
+    myExpressions = expressions;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return AstUtil.joinNodes(myExpressions, N);
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Field.java b/j2k/src/org/jetbrains/jet/j2k/ast/Field.java
new file mode 100644
index 0000000..94fa159
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Field.java
@@ -0,0 +1,75 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+import static org.jetbrains.jet.j2k.Converter.getDefaultInitializer;
+
+/**
+ * @author ignatov
+ */
+public class Field extends Member {
+  final Identifier myIdentifier;
+  final Type myType;
+  final Element myInitializer;
+
+  public Field(Identifier identifier, Set<String> modifiers, Type type, Element initializer) {
+    myIdentifier = identifier;
+    myModifiers = modifiers;
+    myType = type;
+    myInitializer = initializer;
+  }
+
+  public Element getInitializer() {
+    return myInitializer;
+  }
+
+  public Identifier getIdentifier() {
+    return myIdentifier;
+  }
+
+  public Type getType() {
+    return myType;
+  }
+
+  String modifiersToKotlin() {
+    List<String> modifierList = new LinkedList<String>();
+
+    if (isAbstract())
+      modifierList.add(Modifier.ABSTRACT);
+
+    modifierList.add(accessModifier());
+
+    modifierList.add(myModifiers.contains(Modifier.FINAL) ? "val" : "var");
+
+    if (modifierList.size() > 0)
+      return AstUtil.join(modifierList, SPACE) + SPACE;
+
+    return EMPTY;
+  }
+
+  @Override
+  public boolean isStatic() {
+    return myModifiers.contains(Modifier.STATIC);
+  }
+
+  public boolean isFinal() {
+    return myModifiers.contains(Modifier.FINAL);
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String modifier = modifiersToKotlin();
+
+    if (myInitializer.isEmpty())
+      return modifier + myIdentifier.toKotlin() + SPACE + COLON + SPACE + myType.toKotlin() + SPACE + EQUAL + SPACE + getDefaultInitializer(this);
+
+    return modifier + myIdentifier.toKotlin() + SPACE + COLON + SPACE + myType.toKotlin() + SPACE +
+      EQUAL + SPACE + myInitializer.toKotlin();
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/File.java b/j2k/src/org/jetbrains/jet/j2k/ast/File.java
new file mode 100644
index 0000000..d65a160
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/File.java
@@ -0,0 +1,31 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class File extends Node {
+  private final String myPackageName;
+  private final List<Import> myImports;
+  private final List<Class> myClasses;
+
+  public File(String packageName, List<Import> imports, List<Class> classes) {
+    myPackageName = packageName;
+    myImports = imports;
+    myClasses = classes;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    final String common = AstUtil.joinNodes(myImports, N) + N2 + AstUtil.joinNodes(myClasses, N) + N;
+    if (myPackageName.isEmpty())
+      return common;
+    return "namespace" + SPACE + myPackageName + N +
+      common;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ForeachStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ForeachStatement.java
new file mode 100644
index 0000000..08f2a45
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ForeachStatement.java
@@ -0,0 +1,25 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ForeachStatement extends Statement {
+  private final Parameter myVariable;
+  private final Expression myExpression;
+  private final Statement myStatement;
+
+  public ForeachStatement(Parameter variable, Expression expression, Statement statement) {
+    myVariable = variable;
+    myExpression = expression;
+    myStatement = statement;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "for" + SPACE + "(" + myVariable.toKotlin() + SPACE + IN + SPACE + myExpression.toKotlin() + ")" + N +
+      myStatement.toKotlin();
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ForeachWithRangeStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ForeachWithRangeStatement.java
new file mode 100644
index 0000000..b6aa9e6
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ForeachWithRangeStatement.java
@@ -0,0 +1,29 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ForeachWithRangeStatement extends Statement {
+  private final Expression myStart;
+  private final IdentifierImpl myIdentifier;
+  private final Expression myEnd;
+  private final Statement myBody;
+
+  public ForeachWithRangeStatement(IdentifierImpl identifier, Expression start, Expression end, Statement body) {
+    myStart = start;
+    myIdentifier = identifier;
+    myEnd = end;
+    myBody = body;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "for" + SPACE + "(" +
+      myIdentifier.toKotlin() + SPACE + "in" + SPACE + myStart.toKotlin() + ".." + myEnd.toKotlin() +
+      ")" + SPACE +
+      myBody.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Function.java b/j2k/src/org/jetbrains/jet/j2k/ast/Function.java
new file mode 100644
index 0000000..36545c0
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Function.java
@@ -0,0 +1,100 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class Function extends Member {
+  private final Identifier myName;
+  private final Type myType;
+  private final List<Element> myTypeParameters;
+  final Element myParams;
+
+  // TODO: maybe remove it?
+  public void setBlock(Block block) {
+    myBlock = block;
+  }
+
+  Block myBlock;
+
+  public Function(Identifier name, Set<String> modifiers, Type type, List<Element> typeParameters, Element params, Block block) {
+    myName = name;
+    myModifiers = modifiers;
+    myType = type;
+    myTypeParameters = typeParameters;
+    myParams = params;
+    myBlock = block;
+  }
+
+  public List<Element> getTypeParameters() {
+    return myTypeParameters;
+  }
+
+  public Element getParams() {
+    return myParams;
+  }
+
+  public Block getBlock() {
+    return myBlock;
+  }
+
+  private String typeParametersToKotlin() {
+    return myTypeParameters.size() > 0 ? "<" + AstUtil.joinNodes(myTypeParameters, COMMA_WITH_SPACE) + ">" : EMPTY;
+  }
+
+  private boolean hasWhere() {
+    for (Element t : myTypeParameters)
+      if (t instanceof TypeParameter && ((TypeParameter) t).hasWhere())
+        return true;
+    return false;
+  }
+
+  private String typeParameterWhereToKotlin() {
+    if (hasWhere()) {
+      List<String> wheres = new LinkedList<String>();
+      for (Element t : myTypeParameters)
+        if (t instanceof TypeParameter)
+          wheres.add(((TypeParameter) t).getWhereToKotlin());
+      return SPACE + "where" + SPACE + AstUtil.join(wheres, COMMA_WITH_SPACE) + SPACE;
+    }
+    return EMPTY;
+  }
+
+  String modifiersToKotlin() {
+    List<String> modifierList = new LinkedList<String>();
+
+    if (isAbstract())
+      modifierList.add(Modifier.ABSTRACT);
+
+    if (myModifiers.contains(Modifier.OVERRIDE))
+      modifierList.add(Modifier.OVERRIDE);
+
+    if (!myModifiers.contains(Modifier.OVERRIDE) && !myModifiers.contains(Modifier.FINAL))
+      modifierList.add(Modifier.OPEN);
+
+    if (myModifiers.contains(Modifier.NOT_OPEN))
+      modifierList.remove(Modifier.OPEN);
+
+    modifierList.add(accessModifier());
+
+    if (modifierList.size() > 0)
+      return AstUtil.join(modifierList, SPACE) + SPACE;
+
+    return EMPTY;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return modifiersToKotlin() + "fun" + SPACE + myName.toKotlin() + typeParametersToKotlin() + "(" + myParams.toKotlin() + ")" + SPACE + COLON +
+      SPACE + myType.toKotlin() + SPACE +
+      typeParameterWhereToKotlin() +
+      myBlock.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/IMember.java b/j2k/src/org/jetbrains/jet/j2k/ast/IMember.java
new file mode 100644
index 0000000..9c3b406
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/IMember.java
@@ -0,0 +1,10 @@
+package org.jetbrains.jet.j2k.ast;
+
+/**
+ * @author ignatov
+ */
+public interface IMember extends INode {
+  public boolean isStatic();
+
+  boolean isAbstract();
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/INode.java b/j2k/src/org/jetbrains/jet/j2k/ast/INode.java
new file mode 100644
index 0000000..f3ea8ba
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/INode.java
@@ -0,0 +1,18 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public interface INode {
+  @NotNull
+  public String toKotlin();
+
+  @NotNull
+  public Kind getKind();
+
+  public enum Kind {
+    UNDEFINED, TYPE, CONSTRUCTOR, BREAK, CONTINUE, VARARG, TRAIT, ASSIGNMENT_EXPRESSION, CALL_CHAIN,
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Identifier.java b/j2k/src/org/jetbrains/jet/j2k/ast/Identifier.java
new file mode 100644
index 0000000..85b5ae1
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Identifier.java
@@ -0,0 +1,10 @@
+package org.jetbrains.jet.j2k.ast;
+
+/**
+ * @author ignatov
+ */
+public interface Identifier extends INode {
+  public static Identifier EMPTY_IDENTIFIER = new IdentifierImpl("");
+
+  public boolean isEmpty();
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/IdentifierImpl.java b/j2k/src/org/jetbrains/jet/j2k/ast/IdentifierImpl.java
new file mode 100644
index 0000000..98e9452
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/IdentifierImpl.java
@@ -0,0 +1,61 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class IdentifierImpl extends Expression implements Identifier {
+  private final String myName;
+  private boolean myHasDollar = false;
+  private boolean myIsNullable = true;
+  private boolean myQuotingNeeded = true;
+
+  public IdentifierImpl(String name) {
+    myName = name;
+  }
+
+  public IdentifierImpl(String name, boolean isNullable) {
+    myName = name;
+    myIsNullable = isNullable;
+  }
+
+  public IdentifierImpl(String name, boolean hasDollar, boolean isNullable) {
+    myName = name;
+    myHasDollar = hasDollar;
+    myIsNullable = isNullable;
+  }
+
+  public IdentifierImpl(String name, boolean hasDollar, boolean isNullable, boolean quotingNeeded) {
+    this(name, hasDollar,  isNullable);
+    myQuotingNeeded = quotingNeeded;
+  }
+
+  @Override
+  public boolean isEmpty() {
+    return myName.length() == 0;
+  }
+
+  private static String quote(String str) {
+    return BACKTICK + str + BACKTICK;
+  }
+
+  @Override
+  public boolean isNullable() {
+    return myIsNullable;
+  }
+
+  private String ifNeedQuote() {
+    if (myQuotingNeeded && (ONLY_KOTLIN_KEYWORDS.contains(myName) || myName.contains("$")))
+      return quote(myName);
+    return myName;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myHasDollar)
+      return DOLLAR + ifNeedQuote();
+    return ifNeedQuote();
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/IfStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/IfStatement.java
new file mode 100644
index 0000000..3e45436
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/IfStatement.java
@@ -0,0 +1,31 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class IfStatement extends Expression {
+  private final Expression myCondition;
+  private final Statement myThenStatement;
+  private final Statement myElseStatement;
+
+  public IfStatement(Expression condition, Statement thenStatement, Statement elseStatement) {
+    myCondition = condition;
+    myThenStatement = thenStatement;
+    myElseStatement = elseStatement;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String result = "if" + SPACE + "(" + myCondition.toKotlin() + ")" + N + myThenStatement.toKotlin() + N;
+
+    if (myElseStatement != Statement.EMPTY_STATEMENT)
+      return result +
+        "else" + N +
+        myElseStatement.toKotlin();
+
+    return result;
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Import.java b/j2k/src/org/jetbrains/jet/j2k/ast/Import.java
new file mode 100644
index 0000000..854b2fa
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Import.java
@@ -0,0 +1,24 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class Import extends Node {
+  private final String myName;
+
+  public String getName() {
+    return myName;
+  }
+
+  public Import(String name) {
+    myName = name;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "import" + SPACE + myName;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/InProjectionType.java b/j2k/src/org/jetbrains/jet/j2k/ast/InProjectionType.java
new file mode 100644
index 0000000..17d2b63
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/InProjectionType.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class InProjectionType extends Type {
+  private final Type myBound;
+
+  public InProjectionType(Type bound) {
+    myBound = bound;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "in" + SPACE + myBound.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Initializer.java b/j2k/src/org/jetbrains/jet/j2k/ast/Initializer.java
new file mode 100644
index 0000000..d49dc13
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Initializer.java
@@ -0,0 +1,23 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class Initializer extends Member {
+  private final Block myBlock;
+
+  public Initializer(Block block, Set<String> modifiers) {
+    myBlock = block;
+    myModifiers = modifiers;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myBlock.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/IsOperator.java b/j2k/src/org/jetbrains/jet/j2k/ast/IsOperator.java
new file mode 100644
index 0000000..98c6c3a
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/IsOperator.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class IsOperator extends Expression {
+  private final Expression myExpression;
+  private final Element myTypeElement;
+
+  public IsOperator(Expression expression, Element typeElement) {
+    myExpression = expression;
+    myTypeElement = typeElement;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + myExpression.toKotlin() + SPACE + "is" + SPACE + myTypeElement.toKotlin() + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/LabelStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/LabelStatement.java
new file mode 100644
index 0000000..9908938
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/LabelStatement.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class LabelStatement extends Statement {
+  private final Identifier myName;
+  private final Statement myStatement;
+
+  public LabelStatement(Identifier name, Statement statement) {
+    myName = name;
+    myStatement = statement;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return AT + myName.toKotlin() + SPACE + myStatement.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/LiteralExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/LiteralExpression.java
new file mode 100644
index 0000000..4737458
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/LiteralExpression.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class LiteralExpression extends Expression {
+  private final Identifier myIdentifier;
+
+  public LiteralExpression(Identifier identifier) {
+    myIdentifier = identifier;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myIdentifier.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/LocalVariable.java b/j2k/src/org/jetbrains/jet/j2k/ast/LocalVariable.java
new file mode 100644
index 0000000..0c56182
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/LocalVariable.java
@@ -0,0 +1,36 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class LocalVariable extends Expression {
+  private final Identifier myIdentifier;
+  private final Set<String> myModifiersSet;
+  private final Type myType;
+  private final Expression myInitializer;
+
+  public LocalVariable(Identifier identifier, Set<String> modifiersSet, Type type, Expression initializer) {
+    myIdentifier = identifier;
+    myModifiersSet = modifiersSet;
+    myType = type;
+    myInitializer = initializer;
+  }
+
+  public boolean hasModifier(String modifier) {
+    return myModifiersSet.contains(modifier);
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myInitializer.isEmpty())
+      return myIdentifier.toKotlin() + SPACE + COLON + SPACE + myType.toKotlin();
+
+    return myIdentifier.toKotlin() + SPACE + COLON + SPACE + myType.toKotlin() + SPACE +
+      EQUAL + SPACE + myInitializer.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Member.java b/j2k/src/org/jetbrains/jet/j2k/ast/Member.java
new file mode 100644
index 0000000..e0fff02
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Member.java
@@ -0,0 +1,27 @@
+package org.jetbrains.jet.j2k.ast;
+
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public abstract class Member extends Node implements IMember {
+  Set<String> myModifiers;
+
+  String accessModifier() {
+    for (String m : myModifiers)
+      if (m.equals(Modifier.PUBLIC) || m.equals(Modifier.PROTECTED) || m.equals(Modifier.PRIVATE))
+        return m;
+    return EMPTY; // package local converted to internal, but we use internal by default
+  }
+
+  @Override
+  public boolean isAbstract() {
+    return myModifiers.contains(Modifier.ABSTRACT);
+  }
+
+  @Override
+  public boolean isStatic() {
+    return myModifiers.contains(Modifier.STATIC);
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/MethodCallExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/MethodCallExpression.java
new file mode 100644
index 0000000..5bfc87b
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/MethodCallExpression.java
@@ -0,0 +1,42 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class MethodCallExpression extends Expression {
+  private final Expression myMethodCall;
+  private final List<Expression> myArguments;
+  private List<String> myConversions;
+  private final boolean myIsResultNullable;
+  private final List<Type> myTypeParameters;
+
+  public MethodCallExpression(Expression methodCall, List<Expression> arguments, boolean nullable, List<Type> typeParameters) {
+    this(methodCall, arguments, AstUtil.createListWithEmptyString(arguments), nullable, typeParameters);
+  }
+
+  public MethodCallExpression(Expression methodCall, List<Expression> arguments, List<String> conversions, boolean nullable, List<Type> typeParameters) {
+    myMethodCall = methodCall;
+    myArguments = arguments;
+    myConversions = conversions;
+    myIsResultNullable = nullable;
+    myTypeParameters = typeParameters;
+  }
+
+  @Override
+  public boolean isNullable() {
+    return myIsResultNullable;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String typeParamsToKotlin = myTypeParameters.size() > 0 ? "<" + AstUtil.joinNodes(myTypeParameters, COMMA_WITH_SPACE) + ">" : EMPTY;
+    List<String> applyConversions = AstUtil.applyConversions(AstUtil.nodesToKotlin(myArguments), myConversions);
+    return myMethodCall.toKotlin() + typeParamsToKotlin + "(" + AstUtil.join(applyConversions, COMMA_WITH_SPACE) + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Modifier.java b/j2k/src/org/jetbrains/jet/j2k/ast/Modifier.java
new file mode 100644
index 0000000..9292094
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Modifier.java
@@ -0,0 +1,17 @@
+package org.jetbrains.jet.j2k.ast;
+
+/**
+ * @author ignatov
+ */
+public abstract class Modifier {
+  public static final String PUBLIC = "public";
+  public static final String PROTECTED = "protected";
+  public static final String PRIVATE = "private";
+  public static final String INTERNAL = "internal";
+  public static final String STATIC = "static";
+  public static final String ABSTRACT = "abstract";
+  public static final String FINAL = "final";
+  public static final String OPEN = "open";
+  public static final String NOT_OPEN = "not open";
+  public static final String OVERRIDE = "override";
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/NewClassExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/NewClassExpression.java
new file mode 100644
index 0000000..87a5a51
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/NewClassExpression.java
@@ -0,0 +1,45 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class NewClassExpression extends Expression {
+  private final Element myName;
+  private final List<Expression> myArguments;
+  private Expression myQualifier;
+  private List<String> myConversions;
+  private AnonymousClass myAnonymousClass = null;
+
+  public NewClassExpression(Element name, List<Expression> arguments) {
+    myName = name;
+    myQualifier = EMPTY_EXPRESSION;
+    myArguments = arguments;
+    myConversions = AstUtil.createListWithEmptyString(arguments);
+  }
+
+  public NewClassExpression(@NotNull Expression qualifier, @NotNull Element name, @NotNull List<Expression> arguments,
+                            @NotNull List<String> conversions, @Nullable AnonymousClass anonymousClass) {
+    this(name, arguments);
+    myQualifier = qualifier;
+    myConversions = conversions;
+    myAnonymousClass = anonymousClass;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    final String callOperator = myQualifier.isNullable() ? QUESTDOT : DOT;
+    final String qualifier = myQualifier.isEmpty() ? EMPTY : myQualifier.toKotlin() + callOperator;
+    List<String> applyConversions = AstUtil.applyConversions(AstUtil.nodesToKotlin(myArguments), myConversions);
+    String appliedArguments = AstUtil.join(applyConversions, COMMA_WITH_SPACE);
+    return myAnonymousClass != null ?
+      "object" + SPACE + ":" + SPACE + qualifier + myName.toKotlin() + "(" + appliedArguments + ")" + myAnonymousClass.toKotlin() :
+      qualifier + myName.toKotlin() + "(" + appliedArguments + ")";
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Node.java b/j2k/src/org/jetbrains/jet/j2k/ast/Node.java
new file mode 100644
index 0000000..e29f532
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Node.java
@@ -0,0 +1,42 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public abstract class Node implements INode {
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.UNDEFINED;
+  }
+
+  final static Set<String> ONLY_KOTLIN_KEYWORDS = new HashSet<String>(Arrays.asList(
+    "namespace", "as", "type", "val", "var", "fun", "is", "in", "object", "when", "trait", "This"
+  ));
+
+  public final static Set<String> PRIMITIVE_TYPES = new HashSet<String>(Arrays.asList(
+    "double", "float", "long", "int", "short", "byte", "boolean", "char"
+  ));
+
+  static final String N = System.getProperty("line.separator");
+  static final String N2 = N + N;
+  static final String SPACE = " ";
+  static final String EQUAL = "=";
+  static final String EMPTY = "";
+  static final String DOT = ".";
+  static final String QUESTDOT = "?.";
+  static final String COLON = ":";
+  static final String IN = "in";
+  static final String AT = "@";
+  static final String DOLLAR = "$";
+  static final String BACKTICK = "`";
+  static final String QUEST = "?";
+  static final String COMMA_WITH_SPACE = "," + SPACE;
+  static final String STAR = "*";
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/OutProjectionType.java b/j2k/src/org/jetbrains/jet/j2k/ast/OutProjectionType.java
new file mode 100644
index 0000000..dbe7521
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/OutProjectionType.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class OutProjectionType extends Type {
+  private final Type myBound;
+
+  public OutProjectionType(Type bound) {
+    myBound = bound;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "out" + SPACE + myBound.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Parameter.java b/j2k/src/org/jetbrains/jet/j2k/ast/Parameter.java
new file mode 100644
index 0000000..a0258a1
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Parameter.java
@@ -0,0 +1,31 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class Parameter extends Expression {
+  private final Identifier myIdentifier;
+  private final Type myType;
+  private boolean myReadOnly;
+
+  public Parameter(Identifier identifier, Type type) {
+    myIdentifier = identifier;
+    myType = type;
+    myReadOnly = true;
+  }
+
+  public Parameter(IdentifierImpl identifier, Type type, boolean readOnly) {
+    this(identifier, type);
+    myReadOnly = readOnly;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String vararg = myType.getKind() == Kind.VARARG ? "vararg" + SPACE : EMPTY;
+    String var = myReadOnly ? EMPTY : "var" + SPACE;
+    return vararg + var + myIdentifier.toKotlin() + SPACE + COLON + SPACE + myType.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ParameterList.java b/j2k/src/org/jetbrains/jet/j2k/ast/ParameterList.java
new file mode 100644
index 0000000..9528a74
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ParameterList.java
@@ -0,0 +1,23 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class ParameterList extends Expression {
+  private final List<Parameter> myParameters;
+
+  public ParameterList(List<Parameter> parameters) {
+    myParameters = parameters;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return AstUtil.joinNodes(myParameters, COMMA_WITH_SPACE);
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ParenthesizedExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/ParenthesizedExpression.java
new file mode 100644
index 0000000..8a5ac18
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ParenthesizedExpression.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ParenthesizedExpression extends Expression {
+  private final Expression myExpression;
+
+  public ParenthesizedExpression(Expression expression) {
+    myExpression = expression;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + myExpression.toKotlin() + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/PolyadicExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/PolyadicExpression.java
new file mode 100644
index 0000000..f8d1aba
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/PolyadicExpression.java
@@ -0,0 +1,26 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class PolyadicExpression extends Expression {
+  private final List<Expression> myExpressions;
+  private final String myToken;
+
+  public PolyadicExpression(List<Expression> expressions, String token) {
+    super();
+    myExpressions = expressions;
+    myToken = token;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + AstUtil.joinNodes(myExpressions, SPACE + myToken + SPACE) + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/PostfixOperator.java b/j2k/src/org/jetbrains/jet/j2k/ast/PostfixOperator.java
new file mode 100644
index 0000000..036e261
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/PostfixOperator.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class PostfixOperator extends Expression {
+  private final String myOp;
+  private final Expression myExpression;
+
+  public PostfixOperator(String op, Expression expression) {
+    myOp = op;
+    myExpression = expression;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + myExpression.toKotlin() + myOp + ")";
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/PrefixOperator.java b/j2k/src/org/jetbrains/jet/j2k/ast/PrefixOperator.java
new file mode 100644
index 0000000..c94da13
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/PrefixOperator.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class PrefixOperator extends Expression {
+  private final String myOp;
+  private final Expression myExpression;
+
+  public PrefixOperator(String op, Expression expression) {
+    myOp = op;
+    myExpression = expression;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + myOp + myExpression.toKotlin() + ")";
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/PrimitiveType.java b/j2k/src/org/jetbrains/jet/j2k/ast/PrimitiveType.java
new file mode 100644
index 0000000..9a84b46
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/PrimitiveType.java
@@ -0,0 +1,25 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class PrimitiveType extends Type {
+  private final Identifier myType;
+
+  public PrimitiveType(Identifier type) {
+    myType = type;
+  }
+
+  @Override
+  public boolean isNullable() {
+    return false;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myType.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ReferenceElement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ReferenceElement.java
new file mode 100644
index 0000000..c557edf
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ReferenceElement.java
@@ -0,0 +1,26 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class ReferenceElement extends Element {
+  private final Identifier myReference;
+  private final List<Type> myTypes;
+
+  public ReferenceElement(@NotNull Identifier reference, @NotNull List<Type> types) {
+    myReference = reference;
+    myTypes = types;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    String typesIfNeeded = myTypes.size() > 0 ? "<" + AstUtil.joinNodes(myTypes, COMMA_WITH_SPACE) + ">" : EMPTY;
+    return myReference.toKotlin() + typesIfNeeded;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ReturnStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ReturnStatement.java
new file mode 100644
index 0000000..bf2e7ca
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ReturnStatement.java
@@ -0,0 +1,27 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+/**
+ * @author ignatov
+ */
+public class ReturnStatement extends Statement {
+  private final Expression myExpression;
+  private String myConversion = EMPTY;
+
+  public ReturnStatement(Expression expression) {
+    myExpression = expression;
+  }
+
+  public ReturnStatement(final Expression expression, final String conversion) {
+    this(expression);
+    myConversion = conversion;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "return" + SPACE + AstUtil.applyConversionForOneItem(myExpression.toKotlin(), myConversion);
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/StarProjectionType.java b/j2k/src/org/jetbrains/jet/j2k/ast/StarProjectionType.java
new file mode 100644
index 0000000..c409b98
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/StarProjectionType.java
@@ -0,0 +1,14 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class StarProjectionType extends Type {
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return STAR;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Statement.java b/j2k/src/org/jetbrains/jet/j2k/ast/Statement.java
new file mode 100644
index 0000000..1be7eaf
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Statement.java
@@ -0,0 +1,21 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public abstract class Statement extends Element {
+  public static final Statement EMPTY_STATEMENT = new EmptyStatement();
+
+  /**
+   * @author ignatov
+   */
+  private static class EmptyStatement extends Statement {
+    @NotNull
+    @Override
+    public String toKotlin() {
+      return EMPTY;
+    }
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/SuperExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/SuperExpression.java
new file mode 100644
index 0000000..5793efb
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/SuperExpression.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class SuperExpression extends Expression {
+  private final Identifier myIdentifier;
+
+  public SuperExpression(Identifier identifier) {
+    myIdentifier = identifier;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myIdentifier.isEmpty())
+      return "super";
+    return "super" + AT + myIdentifier.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/SynchronizedStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/SynchronizedStatement.java
new file mode 100644
index 0000000..63d3150
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/SynchronizedStatement.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class SynchronizedStatement extends Statement {
+  private final Expression myExpression;
+  private final Block myBlock;
+
+  public SynchronizedStatement(Expression expression, Block block) {
+    myExpression = expression;
+    myBlock = block;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "synchronized" + SPACE + "(" + myExpression.toKotlin() + ")" + SPACE + myBlock.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ThisExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/ThisExpression.java
new file mode 100644
index 0000000..e3bba0d
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ThisExpression.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ThisExpression extends Expression {
+  private final Identifier myIdentifier;
+
+  public ThisExpression(Identifier identifier) {
+    myIdentifier = identifier;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myIdentifier.isEmpty())
+      return "this";
+    return "this" + AT + myIdentifier.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/ThrowStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/ThrowStatement.java
new file mode 100644
index 0000000..298650d
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/ThrowStatement.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class ThrowStatement extends Expression {
+  private final Expression myExpression;
+
+  public ThrowStatement(Expression expression) {
+    myExpression = expression;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "throw" + SPACE + myExpression.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Trait.java b/j2k/src/org/jetbrains/jet/j2k/ast/Trait.java
new file mode 100644
index 0000000..60bcd12
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Trait.java
@@ -0,0 +1,24 @@
+package org.jetbrains.jet.j2k.ast;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * @author ignatov
+ */
+public class Trait extends Class {
+  public Trait(Identifier name, Set<String> modifiers, List<Element> typeParameters, List<Type> extendsTypes,
+               List<Expression> baseClassParams, List<Type> implementsTypes, List<Member> members) {
+    super(name, modifiers, typeParameters, extendsTypes, baseClassParams, implementsTypes, members);
+    TYPE = "trait";
+  }
+
+  @Override
+  String primaryConstructorSignatureToKotlin() {
+    return EMPTY;
+  }
+
+  boolean needOpenModifier() {
+    return false;
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/TryStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/TryStatement.java
new file mode 100644
index 0000000..d9ae141
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/TryStatement.java
@@ -0,0 +1,30 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class TryStatement extends Statement {
+  private final Block myBlock;
+  private final List<CatchStatement> myCatches;
+  private final Block myFinallyBlock;
+
+  public TryStatement(Block block, List<CatchStatement> catches, Block finallyBlock) {
+    myBlock = block;
+    myCatches = catches;
+    myFinallyBlock = finallyBlock;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "try" + N +
+      myBlock.toKotlin() + N +
+      AstUtil.joinNodes(myCatches, N) + N +
+      (myFinallyBlock.isEmpty() ? EMPTY : "finally" + N + myFinallyBlock.toKotlin());
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/Type.java b/j2k/src/org/jetbrains/jet/j2k/ast/Type.java
new file mode 100644
index 0000000..901a7b5
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/Type.java
@@ -0,0 +1,46 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public abstract class Type extends Element {
+  public static final Type EMPTY_TYPE = new EmptyType();
+  boolean myNullable = true;
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.TYPE;
+  }
+
+  public Type convertedToNotNull() {
+    myNullable = false;
+    return this;
+  }
+
+  public boolean isNullable() {
+    return myNullable;
+  }
+
+  String isNullableStr() {
+    return isNullable() ? QUEST : EMPTY;
+  }
+
+  /**
+   * @author ignatov
+   */
+  private static class EmptyType extends Type {
+    @NotNull
+    @Override
+    public String toKotlin() {
+      return "UNRESOLVED_TYPE";
+    }
+
+    @Override
+    public boolean isNullable() {
+      return false;
+    }
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/TypeCastExpression.java b/j2k/src/org/jetbrains/jet/j2k/ast/TypeCastExpression.java
new file mode 100644
index 0000000..ddd82b0
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/TypeCastExpression.java
@@ -0,0 +1,22 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class TypeCastExpression extends Expression {
+  private final Type myType;
+  private final Expression myExpression;
+
+  public TypeCastExpression(Type type, Expression expression) {
+    myType = type;
+    myExpression = expression;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "(" + myExpression.toKotlin() + SPACE + "as" + SPACE + myType.toKotlin() + ")";
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/TypeElement.java b/j2k/src/org/jetbrains/jet/j2k/ast/TypeElement.java
new file mode 100644
index 0000000..542b278
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/TypeElement.java
@@ -0,0 +1,20 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class TypeElement extends Element {
+  private final Type myType;
+
+  public TypeElement(Type type) {
+    myType = type;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myType.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/TypeParameter.java b/j2k/src/org/jetbrains/jet/j2k/ast/TypeParameter.java
new file mode 100644
index 0000000..9e9b07c
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/TypeParameter.java
@@ -0,0 +1,37 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * @author ignatov
+ */
+public class TypeParameter extends Element {
+  private final Identifier myName;
+  private final List<Type> myExtendsTypes;
+
+  public TypeParameter(Identifier name, List<Type> extendsTypes) {
+    myName = name;
+    myExtendsTypes = extendsTypes;
+  }
+
+  public boolean hasWhere() {
+    return myExtendsTypes.size() > 1;
+  }
+
+  @NotNull
+  public String getWhereToKotlin() {
+    if (hasWhere())
+      return myName.toKotlin() + SPACE + COLON + SPACE + myExtendsTypes.get(1).toKotlin();
+    return EMPTY;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    if (myExtendsTypes.size() > 0)
+      return myName.toKotlin() + SPACE + COLON + SPACE + myExtendsTypes.get(0).toKotlin();
+    return myName.toKotlin();
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/VarArg.java b/j2k/src/org/jetbrains/jet/j2k/ast/VarArg.java
new file mode 100644
index 0000000..8ddbc69
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/VarArg.java
@@ -0,0 +1,26 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class VarArg extends Type {
+  private final Type myType;
+
+  public VarArg(Type type) {
+    myType = type;
+  }
+
+  @NotNull
+  @Override
+  public Kind getKind() {
+    return Kind.VARARG;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return myType.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/ast/WhileStatement.java b/j2k/src/org/jetbrains/jet/j2k/ast/WhileStatement.java
new file mode 100644
index 0000000..8502370
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/ast/WhileStatement.java
@@ -0,0 +1,23 @@
+package org.jetbrains.jet.j2k.ast;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author ignatov
+ */
+public class WhileStatement extends Statement {
+  final Expression myCondition;
+  final Statement myStatement;
+
+  public WhileStatement(Expression condition, Statement statement) {
+    myCondition = condition;
+    myStatement = statement;
+  }
+
+  @NotNull
+  @Override
+  public String toKotlin() {
+    return "while" + SPACE + "(" + myCondition.toKotlin() + ")" + N +
+      myStatement.toKotlin();
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/util/AstUtil.java b/j2k/src/org/jetbrains/jet/j2k/util/AstUtil.java
new file mode 100644
index 0000000..3c96203
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/util/AstUtil.java
@@ -0,0 +1,81 @@
+package org.jetbrains.jet.j2k.util;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.ast.Expression;
+import org.jetbrains.jet.j2k.ast.INode;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author ignatov
+ */
+public class AstUtil {
+  private AstUtil() {
+  }
+
+  private static String join(final String[] array, final String delimiter) {
+    StringBuilder buffer = new StringBuilder();
+    boolean haveDelimiter = (delimiter != null);
+
+    for (int i = 0; i < array.length; i++) {
+      buffer.append(array[i]);
+
+      if (haveDelimiter && (i + 1) < array.length)
+        buffer.append(delimiter);
+    }
+
+    return buffer.toString();
+  }
+
+  public static String joinNodes(final List<? extends INode> nodes, final String delimiter) {
+    return join(nodesToKotlin(nodes), delimiter);
+  }
+
+  public static String join(final List<String> array, final String delimiter) {
+    return join(array.toArray(new String[array.size()]), delimiter);
+  }
+
+  public static List<String> nodesToKotlin(List<? extends INode> nodes) {
+    List<String> result = new LinkedList<String>();
+    for (INode n : nodes)
+      result.add(n.toKotlin());
+    return result;
+  }
+
+  public static String upperFirstCharacter(String string) {
+    return string.substring(0, 1).toUpperCase() + string.substring(1);
+  }
+
+  public static List<String> createListWithEmptyString(final List<Expression> arguments) {
+    final List<String> conversions = new LinkedList<String>();
+    //noinspection UnusedDeclaration
+    for (Expression argument : arguments) conversions.add("");
+    return conversions;
+  }
+
+  @NotNull
+  public static List<String> applyConversions(@NotNull List<String> first, @NotNull List<String> second) {
+    List<String> result = new LinkedList<String>();
+    assert first.size() == second.size() : "Lists must have the same size.";
+    for (int i = 0; i < first.size(); i++) {
+      result.add(applyConversionForOneItem(first.get(i), second.get(i)));
+    }
+    return result;
+  }
+
+  @NotNull
+  public static String applyConversionForOneItem(@NotNull String f, @NotNull String s) {
+    if (s.isEmpty())
+      return f;
+    else
+      return "(" + f + ")" + s;
+  }
+
+  public static <T> T getOrElse(Map<T, T> map, T e, T orElse) {
+    if (map.containsKey(e))
+      return map.get(e);
+    return orElse;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/visitors/ElementVisitor.java b/j2k/src/org/jetbrains/jet/j2k/visitors/ElementVisitor.java
new file mode 100644
index 0000000..f18a5f0
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/visitors/ElementVisitor.java
@@ -0,0 +1,91 @@
+package org.jetbrains.jet.j2k.visitors;
+
+import com.intellij.psi.*;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.Converter;
+import org.jetbrains.jet.j2k.ast.*;
+
+import java.util.List;
+
+import static org.jetbrains.jet.j2k.Converter.*;
+
+/**
+ * @author ignatov
+ */
+public class ElementVisitor extends JavaElementVisitor {
+  private Element myResult = Element.EMPTY_ELEMENT;
+
+  @NotNull
+  public Element getResult() {
+    return myResult;
+  }
+
+  @Override
+  public void visitLocalVariable(PsiLocalVariable variable) {
+    super.visitLocalVariable(variable);
+
+    myResult = new LocalVariable(
+      new IdentifierImpl(variable.getName()), // TODO
+      modifiersListToModifiersSet(variable.getModifierList()),
+      typeToType(variable.getType(), Converter.isNotNull(variable.getModifierList())),
+      expressionToExpression(variable.getInitializer())
+    );
+  }
+
+  @Override
+  public void visitExpressionList(PsiExpressionList list) {
+    super.visitExpressionList(list);
+    myResult = new ExpressionList(
+      expressionsToExpressionList(list.getExpressions()),
+      typesToTypeList(list.getExpressionTypes())
+    );
+  }
+
+  @Override
+  public void visitReferenceElement(PsiJavaCodeReferenceElement reference) {
+    super.visitReferenceElement(reference);
+
+    final List<Type> types = typesToTypeList(reference.getTypeParameters());
+    if (!reference.isQualified()) {
+      myResult = new ReferenceElement(
+        new IdentifierImpl(reference.getReferenceName()),
+        types
+      );
+    } else {
+      String result = new IdentifierImpl(reference.getReferenceName()).toKotlin();
+      PsiElement qualifier = reference.getQualifier();
+      while (qualifier != null) {
+        final PsiJavaCodeReferenceElement p = (PsiJavaCodeReferenceElement) qualifier;
+        result = new IdentifierImpl(p.getReferenceName()).toKotlin() + "." + result; // TODO: maybe need to replace by safe call?
+        qualifier = p.getQualifier();
+      }
+      myResult = new ReferenceElement(
+        new IdentifierImpl(result),
+        types
+      );
+    }
+  }
+
+  @Override
+  public void visitTypeElement(PsiTypeElement type) {
+    super.visitTypeElement(type);
+    myResult = new TypeElement(typeToType(type.getType()));
+  }
+
+  @Override
+  public void visitTypeParameter(PsiTypeParameter classParameter) {
+    super.visitTypeParameter(classParameter);
+    myResult = new TypeParameter(
+      new IdentifierImpl(classParameter.getName()), // TODO
+      typesToTypeList(classParameter.getExtendsListTypes())
+    );
+  }
+
+  @Override
+  public void visitParameterList(PsiParameterList list) {
+    super.visitParameterList(list);
+    myResult = new ParameterList(
+      parametersToParameterList(list.getParameters())
+    );
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/visitors/ExpressionVisitor.java b/j2k/src/org/jetbrains/jet/j2k/visitors/ExpressionVisitor.java
new file mode 100644
index 0000000..233e97f
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/visitors/ExpressionVisitor.java
@@ -0,0 +1,534 @@
+package org.jetbrains.jet.j2k.visitors;
+
+import com.intellij.psi.*;
+import com.intellij.psi.tree.IElementType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.j2k.Converter;
+import org.jetbrains.jet.j2k.ast.*;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.*;
+
+import static org.jetbrains.jet.j2k.Converter.*;
+
+/**
+ * @author ignatov
+ */
+public class ExpressionVisitor extends StatementVisitor {
+  Expression myResult = Expression.EMPTY_EXPRESSION;
+
+  @Override
+  public void visitExpression(final PsiExpression expression) {
+    myResult = Expression.EMPTY_EXPRESSION;
+  }
+
+  @NotNull
+  @Override
+  public Expression getResult() {
+    return myResult;
+  }
+
+  @Override
+  public void visitArrayAccessExpression(PsiArrayAccessExpression expression) {
+    super.visitArrayAccessExpression(expression);
+    myResult = new ArrayAccessExpression(
+      expressionToExpression(expression.getArrayExpression()),
+      expressionToExpression(expression.getIndexExpression())
+    );
+  }
+
+  @Override
+  public void visitArrayInitializerExpression(PsiArrayInitializerExpression expression) {
+    super.visitArrayInitializerExpression(expression);
+    myResult = new ArrayInitializerExpression(
+      expressionsToExpressionList(expression.getInitializers())
+    );
+  }
+
+  @Override
+  public void visitAssignmentExpression(PsiAssignmentExpression expression) {
+    super.visitAssignmentExpression(expression);
+
+    // TODO: simplify
+
+    final IElementType tokenType = expression.getOperationSign().getTokenType();
+
+    String secondOp = "";
+    if (tokenType == JavaTokenType.GTGTEQ) secondOp = "shr";
+    if (tokenType == JavaTokenType.LTLTEQ) secondOp = "shl";
+    if (tokenType == JavaTokenType.XOREQ) secondOp = "xor";
+    if (tokenType == JavaTokenType.ANDEQ) secondOp = "and";
+    if (tokenType == JavaTokenType.OREQ) secondOp = "or";
+    if (tokenType == JavaTokenType.GTGTGTEQ) secondOp = "ushr";
+
+    if (!secondOp.isEmpty()) // if not Kotlin operators
+      myResult = new AssignmentExpression(
+        expressionToExpression(expression.getLExpression()),
+        new BinaryExpression(
+          expressionToExpression(expression.getLExpression()),
+          expressionToExpression(expression.getRExpression()),
+          secondOp
+        ),
+        "="
+      );
+    else
+      myResult = new AssignmentExpression(
+        expressionToExpression(expression.getLExpression()),
+        expressionToExpression(expression.getRExpression()),
+        expression.getOperationSign().getText() // TODO
+      );
+  }
+
+  @NotNull
+  private static String getOperatorString(@NotNull IElementType tokenType) {
+    if (tokenType == JavaTokenType.PLUS) return "+";
+    if (tokenType == JavaTokenType.MINUS) return "-";
+    if (tokenType == JavaTokenType.ASTERISK) return "*";
+    if (tokenType == JavaTokenType.DIV) return "/";
+    if (tokenType == JavaTokenType.PERC) return "%";
+    if (tokenType == JavaTokenType.GTGT) return "shr";
+    if (tokenType == JavaTokenType.LTLT) return "shl";
+    if (tokenType == JavaTokenType.XOR) return "xor";
+    if (tokenType == JavaTokenType.AND) return "and";
+    if (tokenType == JavaTokenType.OR) return "or";
+    if (tokenType == JavaTokenType.GTGTGT) return "ushr";
+    if (tokenType == JavaTokenType.GT) return ">";
+    if (tokenType == JavaTokenType.LT) return "<";
+    if (tokenType == JavaTokenType.GE) return ">=";
+    if (tokenType == JavaTokenType.LE) return "<=";
+    if (tokenType == JavaTokenType.EQEQ) return "==";
+    if (tokenType == JavaTokenType.NE) return "!=";
+    if (tokenType == JavaTokenType.ANDAND) return "&&";
+    if (tokenType == JavaTokenType.OROR) return "||";
+    if (tokenType == JavaTokenType.PLUSPLUS) return "++";
+    if (tokenType == JavaTokenType.MINUSMINUS) return "--";
+    if (tokenType == JavaTokenType.EXCL) return "!";
+
+    System.out.println("UNSUPPORTED TOKEN TYPE: " + tokenType.toString());
+    return "";
+  }
+
+  @Override
+  public void visitBinaryExpression(PsiBinaryExpression expression) {
+    super.visitBinaryExpression(expression);
+
+    if (expression.getOperationSign().getTokenType() == JavaTokenType.GTGTGT)
+      myResult = new DummyMethodCallExpression(
+        expressionToExpression(expression.getLOperand()),
+        "ushr",
+        expressionToExpression(expression.getROperand()));
+    else
+      myResult =
+        new BinaryExpression(
+          expressionToExpression(expression.getLOperand()),
+          expressionToExpression(expression.getROperand()),
+          getOperatorString(expression.getOperationSign().getTokenType())
+        );
+  }
+
+  @Override
+  public void visitClassObjectAccessExpression(PsiClassObjectAccessExpression expression) {
+    super.visitClassObjectAccessExpression(expression);
+    myResult = new ClassObjectAccessExpression(elementToElement(expression.getOperand()));
+  }
+
+  @Override
+  public void visitConditionalExpression(PsiConditionalExpression expression) {
+    super.visitConditionalExpression(expression);
+    myResult = new ParenthesizedExpression(
+      new IfStatement(
+        expressionToExpression(expression.getCondition()),
+        expressionToExpression(expression.getThenExpression()),
+        expressionToExpression(expression.getElseExpression())
+      )
+    );
+  }
+
+  @Override
+  public void visitExpressionList(PsiExpressionList list) {
+    super.visitExpressionList(list);
+    myResult = new ExpressionList(expressionsToExpressionList(list.getExpressions()));
+  }
+
+  @Override
+  public void visitInstanceOfExpression(PsiInstanceOfExpression expression) {
+    super.visitInstanceOfExpression(expression);
+    myResult = new IsOperator(
+      expressionToExpression(expression.getOperand()),
+      elementToElement(expression.getCheckType()));
+  }
+
+  @Override
+  public void visitLiteralExpression(PsiLiteralExpression expression) {
+    super.visitLiteralExpression(expression);
+
+    final Object value = expression.getValue();
+    String text = expression.getText();
+    boolean isQuotingNeeded = true;
+
+    final PsiType type = expression.getType();
+    if (type != null) {
+      String canonicalTypeStr = type.getCanonicalText();
+      if (canonicalTypeStr.equals("double") || canonicalTypeStr.equals("java.lang.Double"))
+        text = text.replace("D", "").replace("d", "");
+      if (canonicalTypeStr.equals("float") || canonicalTypeStr.equals("java.lang.Float"))
+        text = text.replace("F", "").replace("f", "") + "." + "flt";
+      if (canonicalTypeStr.equals("long") || canonicalTypeStr.equals("java.lang.Long"))
+        text = text.replace("L", "").replace("l", "");
+      if (canonicalTypeStr.equals("int") || canonicalTypeStr.equals("java.lang.Integer")) // need for hex support
+        text = value != null ? value.toString() : text;
+
+      if (canonicalTypeStr.equals("java.lang.String"))
+        isQuotingNeeded = false;
+      if (canonicalTypeStr.equals("char") || canonicalTypeStr.equals("java.lang.Character"))
+        isQuotingNeeded = false;
+    }
+    myResult = new LiteralExpression(new IdentifierImpl(text, false, false, isQuotingNeeded));
+  }
+
+  @Override
+  public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {
+    super.visitMethodCallExpression(expression);
+    if (!SuperVisitor.isSuper(expression.getMethodExpression()) || !isInsidePrimaryConstructor(expression)) {
+      myResult = // TODO: not resolved
+        new MethodCallExpression(
+          expressionToExpression(expression.getMethodExpression()),
+          expressionsToExpressionList(expression.getArgumentList().getExpressions()),
+          createConversions(expression),
+          typeToType(expression.getType()).isNullable(),
+          typesToTypeList(expression.getTypeArguments())
+        );
+    }
+  }
+
+  @NotNull
+  private static List<String> createConversions(@NotNull PsiCallExpression expression) {
+    List<String> conversions = new LinkedList<String>();
+    PsiExpressionList argumentList = expression.getArgumentList();
+    PsiExpression[] arguments = argumentList != null? argumentList.getExpressions() : new PsiExpression[]{};
+    //noinspection UnusedDeclaration
+    for (final PsiExpression a : arguments) {
+      conversions.add("");
+    }
+
+    PsiMethod resolve = expression.resolveMethod();
+    if (resolve != null) {
+      List<PsiType> expectedTypes = new LinkedList<PsiType>();
+      List<PsiType> actualTypes = new LinkedList<PsiType>();
+
+      for (PsiParameter p : resolve.getParameterList().getParameters())
+        expectedTypes.add(p.getType());
+
+      for (PsiExpression e : arguments)
+        actualTypes.add(e.getType());
+
+      assert actualTypes.size() == expectedTypes.size() : "The type list must have the same length";
+
+      for (int i = 0; i < actualTypes.size(); i++) {
+        PsiType actual = actualTypes.get(i);
+        PsiType expected = expectedTypes.get(i);
+
+        if (isConversionNeeded(actual, expected)) {
+          conversions.set(i, getPrimitiveTypeConversion(expected.getCanonicalText()));
+        }
+      }
+    }
+    return conversions;
+  }
+
+  static boolean isConversionNeeded(@Nullable final PsiType actual,@Nullable final PsiType expected) {
+    if (actual == null || expected == null)
+      return false;
+    Map<String, String> typeMap = new HashMap<String, String>();
+    typeMap.put("java.lang.Byte", "byte");
+    typeMap.put("java.lang.Short", "short");
+    typeMap.put("java.lang.Integer", "int");
+    typeMap.put("java.lang.Long", "long");
+    typeMap.put("java.lang.Float", "float");
+    typeMap.put("java.lang.Double", "double");
+    typeMap.put("java.lang.Character", "char");
+    String expectedStr = expected.getCanonicalText();
+    String actualStr = actual.getCanonicalText();
+    boolean o1 = AstUtil.getOrElse(typeMap, actualStr, "").equals(expectedStr);
+    boolean o2 = AstUtil.getOrElse(typeMap, expectedStr, "").equals(actualStr);
+    return !actualStr.equals(expectedStr) && (!(o1 ^ o2));
+  }
+
+  @NotNull
+  static String getPrimitiveTypeConversion(@NotNull String type) {
+    Map<String, String> conversions = new HashMap<String, String>();
+    conversions.put("byte", "byt");
+    conversions.put("short", "sht");
+    conversions.put("int", "int");
+    conversions.put("long", "lng");
+    conversions.put("float", "flt");
+    conversions.put("double", "dbl");
+    conversions.put("char", "chr");
+
+    conversions.put("java.lang.Byte", "byt");
+    conversions.put("java.lang.Short", "sht");
+    conversions.put("java.lang.Integer", "int");
+    conversions.put("java.lang.Long", "lng");
+    conversions.put("java.lang.Float", "flt");
+    conversions.put("java.lang.Double", "dbl");
+    conversions.put("java.lang.Character", "chr");
+
+    if (conversions.containsKey(type))
+      return "." + conversions.get(type);
+    return "";
+  }
+
+  @Override
+  public void visitCallExpression(PsiCallExpression callExpression) {
+    super.visitCallExpression(callExpression);
+  }
+
+  @Override
+  public void visitNewExpression(PsiNewExpression expression) {
+    super.visitNewExpression(expression);
+
+    if (expression.getArrayInitializer() != null) // new Foo[] {}
+      myResult = createNewEmptyArray(expression);
+    else if (expression.getArrayDimensions().length > 0) { // new Foo[5]
+      myResult = createNewNonEmptyArray(expression);
+    } else { // new Class(): common case
+      myResult = createNewClassExpression(expression);
+    }
+  }
+
+  @NotNull
+  private static Expression createNewClassExpression(@NotNull PsiNewExpression expression) {
+    final PsiAnonymousClass anonymousClass = expression.getAnonymousClass();
+    final PsiMethod constructor = expression.resolveMethod();
+    PsiJavaCodeReferenceElement classReference = expression.getClassOrAnonymousClassReference();
+    final boolean isNotConvertedClass = classReference != null && !Converter.getClassIdentifiers().contains(classReference.getQualifiedName());
+    PsiExpressionList argumentList = expression.getArgumentList();
+    PsiExpression[] arguments = argumentList != null ? argumentList.getExpressions() : new PsiExpression[]{};
+    if (constructor == null || isConstructorPrimary(constructor) || isNotConvertedClass) {
+      return new NewClassExpression(
+        expressionToExpression(expression.getQualifier()),
+        elementToElement(classReference),
+        expressionsToExpressionList(arguments),
+        createConversions(expression),
+        anonymousClass != null ? anonymousClassToAnonymousClass(anonymousClass) : null
+      );
+    }
+    // is constructor secondary
+    final PsiJavaCodeReferenceElement reference = expression.getClassReference();
+    final List<Type> typeParameters = reference != null ? typesToTypeList(reference.getTypeParameters()) : Collections.<Type>emptyList();
+    return new CallChainExpression(
+      new IdentifierImpl(constructor.getName(), false),
+      new MethodCallExpression(
+        new IdentifierImpl("init"),
+        expressionsToExpressionList(arguments),
+        false,
+        typeParameters));
+  }
+
+  @NotNull
+  private static NewClassExpression createNewNonEmptyArray(@NotNull PsiNewExpression expression) {
+    final List<Expression> callExpression = expressionsToExpressionList(expression.getArrayDimensions());
+    callExpression.add(new IdentifierImpl("{null}")); // TODO: remove
+    return new NewClassExpression(
+      typeToType(expression.getType()),
+      callExpression
+    );
+  }
+
+  @NotNull
+  private static Expression createNewEmptyArray(@NotNull PsiNewExpression expression) {
+    return expressionToExpression(expression.getArrayInitializer());
+  }
+
+  @Override
+  public void visitParenthesizedExpression(PsiParenthesizedExpression expression) {
+    super.visitParenthesizedExpression(expression);
+    myResult = new ParenthesizedExpression(
+      expressionToExpression(expression.getExpression())
+    );
+  }
+
+  @Override
+  public void visitPostfixExpression(PsiPostfixExpression expression) {
+    super.visitPostfixExpression(expression);
+    myResult = new PostfixOperator(
+      getOperatorString(expression.getOperationSign().getTokenType()),
+      expressionToExpression(expression.getOperand())
+    );
+  }
+
+  @Override
+  public void visitPrefixExpression(PsiPrefixExpression expression) {
+    super.visitPrefixExpression(expression);
+    if (expression.getOperationTokenType() == JavaTokenType.TILDE)
+      myResult = new DummyMethodCallExpression(
+        new ParenthesizedExpression(expressionToExpression(expression.getOperand())), "inv", Expression.EMPTY_EXPRESSION
+      );
+    else
+      myResult = new PrefixOperator(
+        getOperatorString(expression.getOperationSign().getTokenType()),
+        expressionToExpression(expression.getOperand())
+      );
+  }
+
+  @Override
+  public void visitReferenceExpression(PsiReferenceExpression expression) {
+    super.visitReferenceExpression(expression);
+
+    final boolean isFieldReference = isFieldReference(expression, getContainingClass(expression));
+    final boolean hasDollar = isFieldReference && isInsidePrimaryConstructor(expression);
+    final boolean insideSecondaryConstructor = isInsideSecondaryConstructor(expression);
+    final boolean hasReceiver = isFieldReference && insideSecondaryConstructor;
+    final boolean isThis = isThisExpression(expression);
+    final boolean isNullable = typeToType(expression.getType()).isNullable();
+    final String className = getClassNameWithConstructor(expression);
+
+    Expression identifier = new IdentifierImpl(expression.getReferenceName(), isNullable);
+
+    if (hasDollar)
+      identifier = new IdentifierImpl(expression.getReferenceName(), hasDollar, isNullable);
+    else {
+      final String temporaryObject = "__";
+      if (hasReceiver)
+        identifier = new CallChainExpression(new IdentifierImpl(temporaryObject, false), new IdentifierImpl(expression.getReferenceName(), isNullable));
+      else if (insideSecondaryConstructor && isThis)
+        identifier = new IdentifierImpl("val " + temporaryObject + " = " + className); // TODO: hack
+    }
+
+    myResult = new CallChainExpression(
+      expressionToExpression(expression.getQualifierExpression()),
+      identifier // TODO: if type exists so identifier is nullable
+    );
+  }
+
+  @NotNull
+  static String getClassNameWithConstructor(@NotNull PsiReferenceExpression expression) {
+    PsiElement context = expression.getContext();
+    while (context != null) {
+      if (context instanceof PsiMethod && ((PsiMethod) context).isConstructor()) {
+        final PsiClass containingClass = ((PsiMethod) context).getContainingClass();
+        if (containingClass != null) {
+          final PsiIdentifier identifier = containingClass.getNameIdentifier();
+          if (identifier != null)
+            return identifier.getText();
+        }
+      }
+      context = context.getContext();
+    }
+    return "";
+  }
+
+  @NotNull
+  static String getClassName(@NotNull PsiExpression expression) {
+    PsiElement context = expression.getContext();
+    while (context != null) {
+      if (context instanceof PsiClass) {
+        final PsiClass containingClass = (PsiClass) context;
+        final PsiIdentifier identifier = containingClass.getNameIdentifier();
+        if (identifier != null)
+          return identifier.getText();
+      }
+      context = context.getContext();
+    }
+    return "";
+  }
+
+  private static boolean isFieldReference(@NotNull PsiReferenceExpression expression, PsiClass currentClass) {
+    final PsiReference reference = expression.getReference();
+    if (reference != null) {
+      final PsiElement resolvedReference = reference.resolve();
+      if (resolvedReference != null) {
+        if (resolvedReference instanceof PsiField) {
+          return ((PsiField) resolvedReference).getContainingClass() == currentClass;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static boolean isInsideSecondaryConstructor(PsiReferenceExpression expression) {
+    PsiElement context = expression.getContext();
+    while (context != null) {
+      if (context instanceof PsiMethod && ((PsiMethod) context).isConstructor())
+        return !isConstructorPrimary((PsiMethod) context);
+      context = context.getContext();
+    }
+    return false;
+  }
+
+  private static boolean isInsidePrimaryConstructor(PsiExpression expression) {
+    PsiElement context = expression.getContext();
+    while (context != null) {
+      if (context instanceof PsiMethod && ((PsiMethod) context).isConstructor())
+        return isConstructorPrimary((PsiMethod) context);
+      context = context.getContext();
+    }
+    return false;
+  }
+
+  @Nullable
+  private static PsiClass getContainingClass(@NotNull PsiExpression expression) {
+    PsiElement context = expression.getContext();
+    while (context != null) {
+      if (context instanceof PsiMethod && ((PsiMethod) context).isConstructor())
+        return ((PsiMethod) context).getContainingClass();
+      context = context.getContext();
+    }
+    return null;
+  }
+
+  private static boolean isThisExpression(PsiReferenceExpression expression) {
+    for (PsiReference r : expression.getReferences())
+      if (r.getCanonicalText().equals("this")) {
+        final PsiElement res = r.resolve();
+        if (res != null && res instanceof PsiMethod && ((PsiMethod) res).isConstructor())
+          return true;
+      }
+    return false;
+  }
+
+  @Override
+  public void visitSuperExpression(PsiSuperExpression expression) {
+    super.visitSuperExpression(expression);
+    final PsiJavaCodeReferenceElement qualifier = expression.getQualifier();
+    myResult = new SuperExpression(
+      qualifier != null ?
+        new IdentifierImpl(qualifier.getQualifiedName()) :
+        Identifier.EMPTY_IDENTIFIER
+    );
+  }
+
+  @Override
+  public void visitThisExpression(PsiThisExpression expression) {
+    super.visitThisExpression(expression);
+    final PsiJavaCodeReferenceElement qualifier = expression.getQualifier();
+    myResult = new ThisExpression(
+      qualifier != null ?
+        new IdentifierImpl(qualifier.getQualifiedName()) :
+        Identifier.EMPTY_IDENTIFIER
+    );
+  }
+
+  @Override
+  public void visitTypeCastExpression(PsiTypeCastExpression expression) {
+    super.visitTypeCastExpression(expression);
+
+    final PsiTypeElement castType = expression.getCastType();
+    if (castType != null) {
+      myResult = new TypeCastExpression(
+        typeToType(castType.getType()),
+        expressionToExpression(expression.getOperand())
+      );
+    }
+  }
+
+  @Override
+  public void visitPolyadicExpression(PsiPolyadicExpression expression) {
+    super.visitPolyadicExpression(expression);
+    myResult = new PolyadicExpression(
+      expressionsToExpressionList(expression.getOperands()),
+      getOperatorString(expression.getOperationTokenType())
+    );
+  }
+}
\ No newline at end of file
diff --git a/j2k/src/org/jetbrains/jet/j2k/visitors/StatementVisitor.java b/j2k/src/org/jetbrains/jet/j2k/visitors/StatementVisitor.java
new file mode 100644
index 0000000..d971851
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/visitors/StatementVisitor.java
@@ -0,0 +1,350 @@
+package org.jetbrains.jet.j2k.visitors;
+
+import com.intellij.psi.*;
+import com.intellij.psi.search.searches.ReferencesSearch;
+import com.intellij.psi.tree.IElementType;
+import com.intellij.psi.util.PsiUtil;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.j2k.Converter;
+import org.jetbrains.jet.j2k.ast.*;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.jetbrains.jet.j2k.Converter.*;
+import static org.jetbrains.jet.j2k.visitors.ExpressionVisitor.getPrimitiveTypeConversion;
+import static org.jetbrains.jet.j2k.visitors.ExpressionVisitor.isConversionNeeded;
+
+/**
+ * @author ignatov
+ */
+public class StatementVisitor extends ElementVisitor {
+  private Statement myResult = Statement.EMPTY_STATEMENT;
+
+  @NotNull
+  @Override
+  public Statement getResult() {
+    return myResult;
+  }
+
+  @Override
+  public void visitAssertStatement(PsiAssertStatement statement) {
+    super.visitAssertStatement(statement);
+    myResult = new AssertStatement(
+      expressionToExpression(statement.getAssertCondition()),
+      expressionToExpression(statement.getAssertDescription())
+    );
+  }
+
+  @Override
+  public void visitBlockStatement(PsiBlockStatement statement) {
+    super.visitBlockStatement(statement);
+    myResult = new Block(
+      statementsToStatementList(statement.getCodeBlock().getStatements()),
+      true
+    );
+  }
+
+  @Override
+  public void visitBreakStatement(PsiBreakStatement statement) {
+    super.visitBreakStatement(statement);
+    if (statement.getLabelIdentifier() == null)
+      myResult = new BreakStatement();
+    else
+      myResult = new BreakStatement(
+        identifierToIdentifier(statement.getLabelIdentifier())
+      );
+  }
+
+  @Override
+  public void visitContinueStatement(PsiContinueStatement statement) {
+    super.visitContinueStatement(statement);
+    if (statement.getLabelIdentifier() == null)
+      myResult = new ContinueStatement();
+    else
+      myResult = new ContinueStatement(
+        identifierToIdentifier(statement.getLabelIdentifier())
+      );
+  }
+
+  @Override
+  public void visitDeclarationStatement(PsiDeclarationStatement statement) {
+    super.visitDeclarationStatement(statement);
+    myResult = new DeclarationStatement(
+      elementsToElementList(statement.getDeclaredElements())
+    );
+  }
+
+  @Override
+  public void visitDoWhileStatement(PsiDoWhileStatement statement) {
+    super.visitDoWhileStatement(statement);
+    myResult = new DoWhileStatement(
+      expressionToExpression(statement.getCondition()),
+      statementToStatement(statement.getBody())
+    );
+  }
+
+  @Override
+  public void visitExpressionStatement(PsiExpressionStatement statement) {
+    super.visitExpressionStatement(statement);
+    myResult = expressionToExpression(statement.getExpression());
+  }
+
+  @Override
+  public void visitExpressionListStatement(PsiExpressionListStatement statement) {
+    super.visitExpressionListStatement(statement);
+    myResult =
+      new ExpressionListStatement(expressionsToExpressionList(statement.getExpressionList().getExpressions()));
+  }
+
+  @Override
+  public void visitForStatement(@NotNull PsiForStatement statement) {
+    super.visitForStatement(statement);
+
+    final PsiStatement initialization = statement.getInitialization();
+    final PsiStatement update = statement.getUpdate();
+    final PsiExpression condition = statement.getCondition();
+    final PsiLocalVariable firstChild = initialization != null && initialization.getFirstChild() instanceof PsiLocalVariable ?
+      (PsiLocalVariable) initialization.getFirstChild() : null;
+
+    final IElementType operationTokenType = condition != null && condition instanceof PsiBinaryExpression ?
+      ((PsiBinaryExpression) condition).getOperationTokenType() : null;
+    if (
+      initialization != null &&
+        initialization instanceof PsiDeclarationStatement
+        && initialization.getFirstChild() == initialization.getLastChild()
+        && condition != null
+        && update != null
+        && update.getChildren().length == 1
+        && update.getChildren()[0] instanceof PsiPostfixExpression
+        && ((PsiPostfixExpression) update.getChildren()[0]).getOperationTokenType() == JavaTokenType.PLUSPLUS
+        && operationTokenType != null
+        && (operationTokenType == JavaTokenType.LT || operationTokenType == JavaTokenType.LE)
+        && initialization.getFirstChild() != null
+        && initialization.getFirstChild() instanceof PsiLocalVariable
+        && firstChild != null
+        && firstChild.getNameIdentifier() != null
+        && isOnceWritableIterator(firstChild)
+      ) {
+      final Expression end = expressionToExpression(((PsiBinaryExpression) condition).getROperand());
+      final Expression endExpression = operationTokenType == JavaTokenType.LT ?
+        new BinaryExpression(end, new IdentifierImpl("1"), "-") :
+        end;
+      myResult = new ForeachWithRangeStatement(
+        new IdentifierImpl(firstChild.getName()),
+        expressionToExpression(firstChild.getInitializer()),
+        endExpression,
+        statementToStatement(statement.getBody())
+      );
+    } else { // common case: while loop instead of for loop
+      List<Statement> forStatements = new LinkedList<Statement>();
+      forStatements.add(statementToStatement(initialization));
+      forStatements.add(new WhileStatement(
+        expressionToExpression(condition),
+        new Block(
+          Arrays.asList(statementToStatement(statement.getBody()),
+            new Block(Arrays.asList(statementToStatement(update)))))));
+      myResult = new Block(forStatements);
+    }
+  }
+
+  private static boolean isOnceWritableIterator(PsiLocalVariable firstChild) {
+    int counter = 0;
+    if (firstChild != null)
+      for (PsiReference r : (ReferencesSearch.search(firstChild))) {
+        if (r instanceof PsiExpression) {
+          if (PsiUtil.isAccessedForWriting((PsiExpression) r))
+            counter++;
+        }
+      }
+    return counter == 1; // only increment usage
+  }
+
+  @Override
+  public void visitForeachStatement(PsiForeachStatement statement) {
+    super.visitForeachStatement(statement);
+    myResult = new ForeachStatement(
+      parameterToParameter(statement.getIterationParameter()),
+      expressionToExpression(statement.getIteratedValue()),
+      statementToStatement(statement.getBody())
+    );
+  }
+
+  @Override
+  public void visitIfStatement(PsiIfStatement statement) {
+    super.visitIfStatement(statement);
+    myResult = new IfStatement(
+      expressionToExpression(statement.getCondition()),
+      statementToStatement(statement.getThenBranch()),
+      statementToStatement(statement.getElseBranch())
+    );
+  }
+
+  @Override
+  public void visitLabeledStatement(PsiLabeledStatement statement) {
+    super.visitLabeledStatement(statement);
+    myResult = new LabelStatement(
+      identifierToIdentifier(statement.getLabelIdentifier()),
+      statementToStatement(statement.getStatement())
+    );
+  }
+
+  @Override
+  public void visitSwitchLabelStatement(PsiSwitchLabelStatement statement) {
+    super.visitSwitchLabelStatement(statement);
+    myResult = statement.isDefaultCase() ?
+      new DefaultSwitchLabelStatement() :
+      new SwitchLabelStatement(expressionToExpression(statement.getCaseValue()));
+  }
+
+  @Override
+  public void visitSwitchStatement(PsiSwitchStatement statement) {
+    super.visitSwitchStatement(statement);
+    myResult = new SwitchContainer(
+      expressionToExpression(statement.getExpression()),
+      switchBodyToCases(statement.getBody())
+    );
+  }
+
+  @NotNull
+  private static List<CaseContainer> switchBodyToCases(@Nullable final PsiCodeBlock body) {
+    final List<List<PsiStatement>> cases = splitToCases(body);
+    final List<PsiStatement> allSwitchStatements = body != null ? Arrays.asList(body.getStatements()) : Collections.<PsiStatement>emptyList();
+
+    List<CaseContainer> result = new LinkedList<CaseContainer>();
+    List<Statement> pendingLabels = new LinkedList<Statement>();
+    int i = 0;
+    for (List<PsiStatement> ls : cases) {
+      assert ls.size() > 0;
+      PsiStatement label = ls.get(0);
+      assert label instanceof PsiSwitchLabelStatement;
+
+      assert allSwitchStatements.get(i) == label : "not a right index";
+
+      if (ls.size() > 1) {
+        pendingLabels.add(statementToStatement(label));
+        List<PsiStatement> slice = ls.subList(1, ls.size());
+
+        if (!containsBreak(slice)) {
+          List<Statement> statements = statementsToStatementList(slice);
+          statements.addAll(
+            statementsToStatementList(getAllToNextBreak(allSwitchStatements, i + ls.size()))
+          );
+          result.add(new CaseContainer(pendingLabels, statements));
+          pendingLabels = new LinkedList<Statement>();
+        } else {
+          result.add(new CaseContainer(pendingLabels, statementsToStatementList(slice)));
+          pendingLabels = new LinkedList<Statement>();
+        }
+      } else // ls.size() == 1
+        pendingLabels.add(statementToStatement(label));
+      i += ls.size();
+    }
+    return result;
+  }
+
+  private static boolean containsBreak(@NotNull final List<PsiStatement> slice) {
+    for (PsiStatement s : slice)
+      if (s instanceof PsiBreakStatement)
+        return true;
+    return false;
+  }
+
+  private static List<PsiStatement> getAllToNextBreak(@NotNull final List<PsiStatement> allStatements, final int start) {
+    List<PsiStatement> result = new LinkedList<PsiStatement>();
+    for (int i = start; i < allStatements.size(); i++) {
+      PsiStatement s = allStatements.get(i);
+      if (s instanceof PsiBreakStatement)
+        return result;
+      if (!(s instanceof PsiSwitchLabelStatement))
+        result.add(s);
+    }
+    return result;
+  }
+
+  @NotNull
+  private static List<List<PsiStatement>> splitToCases(@Nullable final PsiCodeBlock body) {
+    List<List<PsiStatement>> cases = new LinkedList<List<PsiStatement>>();
+    List<PsiStatement> currentCaseStatements = new LinkedList<PsiStatement>();
+    boolean isFirst = true;
+    if (body != null) {
+      for (PsiStatement s : body.getStatements()) {
+        if (s instanceof PsiSwitchLabelStatement) {
+          if (isFirst)
+            isFirst = false;
+          else {
+            cases.add(currentCaseStatements);
+            currentCaseStatements = new LinkedList<PsiStatement>();
+          }
+        }
+        currentCaseStatements.add(s);
+      }
+      cases.add(currentCaseStatements);
+    }
+    return cases;
+  }
+
+  @Override
+  public void visitSynchronizedStatement(PsiSynchronizedStatement statement) {
+    super.visitSynchronizedStatement(statement);
+    myResult = new SynchronizedStatement(
+      expressionToExpression(statement.getLockExpression()),
+      blockToBlock(statement.getBody())
+    );
+  }
+
+  @Override
+  public void visitThrowStatement(PsiThrowStatement statement) {
+    super.visitThrowStatement(statement);
+    myResult = new ThrowStatement(
+      expressionToExpression(statement.getException())
+    );
+  }
+
+  @Override
+  public void visitTryStatement(PsiTryStatement statement) {
+    super.visitTryStatement(statement);
+
+    List<CatchStatement> catches = new LinkedList<CatchStatement>();
+    for (int i = 0; i < statement.getCatchBlocks().length; i++) {
+      catches.add(new CatchStatement(
+        parameterToParameter(statement.getCatchBlockParameters()[i]),
+        blockToBlock(statement.getCatchBlocks()[i], true)
+      ));
+    }
+
+    myResult = new TryStatement(
+      blockToBlock(statement.getTryBlock(), true),
+      catches,
+      blockToBlock(statement.getFinallyBlock(), true)
+    );
+  }
+
+  @Override
+  public void visitWhileStatement(PsiWhileStatement statement) {
+    super.visitWhileStatement(statement);
+    myResult = new WhileStatement(
+      expressionToExpression(statement.getCondition()),
+      statementToStatement(statement.getBody())
+    );
+  }
+
+  @Override
+  public void visitReturnStatement(PsiReturnStatement statement) {
+    super.visitReturnStatement(statement);
+    PsiExpression returnValue = statement.getReturnValue();
+    String conversion = "";
+
+    PsiType methodReturnType = Converter.getMethodReturnType();
+    if (returnValue != null && methodReturnType != null && isConversionNeeded(returnValue.getType(), methodReturnType)) {
+      conversion = getPrimitiveTypeConversion(methodReturnType.getCanonicalText());
+    }
+    myResult = new ReturnStatement(
+      expressionToExpression(returnValue),
+      conversion
+    );
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/visitors/SuperVisitor.java b/j2k/src/org/jetbrains/jet/j2k/visitors/SuperVisitor.java
new file mode 100644
index 0000000..16fcf40
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/visitors/SuperVisitor.java
@@ -0,0 +1,38 @@
+package org.jetbrains.jet.j2k.visitors;
+
+import com.intellij.psi.*;
+
+import java.util.HashSet;
+
+
+/**
+ * @author ignatov
+ */
+public class SuperVisitor extends JavaRecursiveElementVisitor {
+  private final HashSet<PsiExpressionList> myResolvedSuperCallParameters;
+
+  public SuperVisitor() {
+    myResolvedSuperCallParameters = new HashSet<PsiExpressionList>();
+  }
+
+  public HashSet<PsiExpressionList> getResolvedSuperCallParameters() {
+    return myResolvedSuperCallParameters;
+  }
+
+  @Override
+  public void visitMethodCallExpression(PsiMethodCallExpression expression) {
+    super.visitMethodCallExpression(expression);
+    if (isSuper(expression.getMethodExpression()))
+      myResolvedSuperCallParameters.add(expression.getArgumentList());
+  }
+
+  static boolean isSuper(PsiReference r) {
+    if (r.getCanonicalText().equals("super")) {
+      final PsiElement baseConstructor = r.resolve();
+      if (baseConstructor != null && baseConstructor instanceof PsiMethod && ((PsiMethod) baseConstructor).isConstructor()) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/visitors/ThisVisitor.java b/j2k/src/org/jetbrains/jet/j2k/visitors/ThisVisitor.java
new file mode 100644
index 0000000..98fff4e
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/visitors/ThisVisitor.java
@@ -0,0 +1,35 @@
+package org.jetbrains.jet.j2k.visitors;
+
+import com.intellij.psi.*;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashSet;
+
+/**
+ * @author ignatov
+ */
+public class ThisVisitor extends JavaRecursiveElementVisitor {
+  private final HashSet<PsiMethod> myResolvedConstructors = new HashSet<PsiMethod>();
+
+  @Override
+  public void visitReferenceExpression(PsiReferenceExpression expression) {
+    for (PsiReference r : expression.getReferences())
+      if (r.getCanonicalText().equals("this")) {
+        final PsiElement res = r.resolve();
+        if (res != null && res instanceof PsiMethod && ((PsiMethod) res).isConstructor())
+          myResolvedConstructors.add((PsiMethod) res);
+      }
+  }
+
+  @Nullable
+  public PsiMethod getPrimaryConstructor() {
+    if (myResolvedConstructors.size() > 0) {
+      PsiMethod first = myResolvedConstructors.toArray(new PsiMethod[myResolvedConstructors.size()])[0];
+      for (PsiMethod m : myResolvedConstructors)
+        if (m.hashCode() != first.hashCode())
+          return null;
+      return first;
+    }
+    return null;
+  }
+}
diff --git a/j2k/src/org/jetbrains/jet/j2k/visitors/TypeVisitor.java b/j2k/src/org/jetbrains/jet/j2k/visitors/TypeVisitor.java
new file mode 100644
index 0000000..7be5bc4
--- /dev/null
+++ b/j2k/src/org/jetbrains/jet/j2k/visitors/TypeVisitor.java
@@ -0,0 +1,157 @@
+package org.jetbrains.jet.j2k.visitors;
+
+import com.intellij.psi.*;
+import com.intellij.psi.impl.source.PsiClassReferenceType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.j2k.ast.*;
+import org.jetbrains.jet.j2k.util.AstUtil;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.jetbrains.jet.j2k.Converter.typeToType;
+import static org.jetbrains.jet.j2k.Converter.typesToTypeList;
+
+/**
+ * @author ignatov
+ */
+public class TypeVisitor extends PsiTypeVisitor<Type> {
+  private Type myResult = Type.EMPTY_TYPE;
+
+  @NotNull
+  public Type getResult() {
+    return myResult;
+  }
+
+  @Override
+  public Type visitPrimitiveType(PsiPrimitiveType primitiveType) {
+    final String name = primitiveType.getCanonicalText();
+    final IdentifierImpl identifier = new IdentifierImpl(name);
+
+    if (name.equals("void"))
+      myResult = new PrimitiveType(new IdentifierImpl("Unit"));
+    else if (Node.PRIMITIVE_TYPES.contains(name))
+      myResult = new PrimitiveType(new IdentifierImpl(AstUtil.upperFirstCharacter(name)));
+    else
+      myResult = new PrimitiveType(identifier);
+    return super.visitPrimitiveType(primitiveType);
+  }
+
+  @Override
+  public Type visitArrayType(PsiArrayType arrayType) {
+    if (myResult == Type.EMPTY_TYPE)
+      myResult = new ArrayType(typeToType(arrayType.getComponentType()));
+    return super.visitArrayType(arrayType);
+  }
+
+  @Override
+  public Type visitClassType(PsiClassType classType) {
+    final IdentifierImpl identifier = constructClassTypeIdentifier(classType);
+    final List<Type> resolvedClassTypeParams = createRawTypesForResolvedReference(classType);
+
+    if (classType.getParameterCount() == 0 && resolvedClassTypeParams.size() > 0)
+      myResult = new ClassType(identifier, resolvedClassTypeParams);
+    else
+      myResult = new ClassType(identifier, typesToTypeList(classType.getParameters()));
+    return super.visitClassType(classType);
+  }
+
+  @NotNull
+  private static IdentifierImpl constructClassTypeIdentifier(@NotNull PsiClassType classType) {
+    final PsiClass psiClass = classType.resolve();
+    if (psiClass != null) {
+      String qualifiedName = psiClass.getQualifiedName();
+      if (qualifiedName != null) {
+        if (qualifiedName.equals("java.lang.Iterable"))
+          return new IdentifierImpl("java.lang.Iterable");
+        if (qualifiedName.equals("java.util.Iterator"))
+          return new IdentifierImpl("java.util.Iterator");
+      }
+    }
+    final String classTypeName = createQualifiedName(classType);
+
+    if (classTypeName.isEmpty())
+      return new IdentifierImpl(getClassTypeName(classType));
+
+    return new IdentifierImpl(classTypeName);
+  }
+
+  @NotNull
+  private static String createQualifiedName(@NotNull PsiClassType classType) {
+    String classTypeName = "";
+    if (classType instanceof PsiClassReferenceType) {
+      final PsiJavaCodeReferenceElement reference = ((PsiClassReferenceType) classType).getReference();
+      if (reference.isQualified()) {
+        String result = new IdentifierImpl(reference.getReferenceName()).toKotlin();
+        PsiElement qualifier = reference.getQualifier();
+        while (qualifier != null) {
+          final PsiJavaCodeReferenceElement p = (PsiJavaCodeReferenceElement) qualifier;
+          result = new IdentifierImpl(p.getReferenceName()).toKotlin() + "." + result; // TODO: maybe need to replace by safe call?
+          qualifier = p.getQualifier();
+        }
+        classTypeName = result;
+      }
+    }
+    return classTypeName;
+  }
+
+  @NotNull
+  private static List<Type> createRawTypesForResolvedReference(@NotNull PsiClassType classType) {
+    final List<Type> typeParams = new LinkedList<Type>();
+    if (classType instanceof PsiClassReferenceType) {
+      final PsiJavaCodeReferenceElement reference = ((PsiClassReferenceType) classType).getReference();
+      final PsiElement resolve = reference.resolve();
+      if (resolve != null) {
+        if (resolve instanceof PsiClass)
+          //noinspection UnusedDeclaration
+          for (PsiTypeParameter p : ((PsiClass) resolve).getTypeParameters())
+            typeParams.add(new StarProjectionType());
+      }
+    }
+    return typeParams;
+  }
+
+  @NotNull
+  private static String getClassTypeName(@NotNull PsiClassType classType) {
+    String canonicalTypeStr = classType.getCanonicalText();
+    if (canonicalTypeStr.equals("java.lang.Object")) return "Any";
+    if (canonicalTypeStr.equals("java.lang.Byte")) return "Byte";
+    if (canonicalTypeStr.equals("java.lang.Character")) return "Char";
+    if (canonicalTypeStr.equals("java.lang.Double")) return "Double";
+    if (canonicalTypeStr.equals("java.lang.Float")) return "Float";
+    if (canonicalTypeStr.equals("java.lang.Integer")) return "Int";
+    if (canonicalTypeStr.equals("java.lang.Long")) return "Long";
+    if (canonicalTypeStr.equals("java.lang.Short")) return "Short";
+    if (canonicalTypeStr.equals("java.lang.Boolean")) return "Boolean";
+    return classType.getClassName() != null ? classType.getClassName() : classType.getCanonicalText();
+  }
+
+  @Override
+  public Type visitWildcardType(PsiWildcardType wildcardType) {
+    if (wildcardType.isExtends())
+      myResult = new OutProjectionType(typeToType(wildcardType.getExtendsBound()));
+    else if (wildcardType.isSuper())
+      myResult = new InProjectionType(typeToType(wildcardType.getSuperBound()));
+    else
+      myResult = new StarProjectionType();
+    return super.visitWildcardType(wildcardType);
+  }
+
+  @Override
+  public Type visitEllipsisType(PsiEllipsisType ellipsisType) {
+    myResult = new VarArg(typeToType(ellipsisType.getComponentType()));
+    return super.visitEllipsisType(ellipsisType);
+  }
+
+  @Override
+  public Type visitCapturedWildcardType(PsiCapturedWildcardType capturedWildcardType) {
+    return super.visitCapturedWildcardType(capturedWildcardType);
+  }
+
+  @Override
+  public Type visitDisjunctionType(PsiDisjunctionType disjunctionType) {
+    return super.visitDisjunctionType(disjunctionType);
+  }
+}
+
